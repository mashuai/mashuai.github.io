<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>代码拾遗</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="代码拾遗">
<meta property="og:url" content="https://mashuai.github.io/index.html">
<meta property="og:site_name" content="代码拾遗">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代码拾遗">
  
    <link rel="alternative" href="/atom.xml" title="代码拾遗" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
  (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-2889123346235419",
      enable_page_level_ads: true
    });
  </script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1cf66cb20b7f58505ec9ca2e88537f6e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">代码拾遗</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/projects">Projects</a>
        
          <a class="main-nav-link" href="/velocity">Velocity</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mashuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-spring-mvc-controller" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/10/spring-mvc-controller/" class="article-date">
  <time datetime="2018-04-09T16:39:10.000Z" itemprop="datePublished">2018-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/spring-mvc-controller/">SpringMVC 教程 - Controller</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="声明Controller"><a href="#声明Controller" class="headerlink" title="声明Controller"></a>声明Controller</h5><p>Controller也是一个标准的Spring bean，可以在Servlet的<code>WebApplicationContext</code>中定义。也可以使用<code>@Controller</code>注解，Spring会扫描注解自动注册为Spring的bean。<br>开启自动注册<code>@Controller</code>注解的bean可以使用如下Java Config的配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(<span class="string">"org.example.web"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用xml配置，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">        http://www.springframework.org/schema/beans</div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example.web"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h5><p><code>@RequestMapping</code>可以将请求映射到具体的Controller方法上。通过找到匹配的url，http 方法，请求参数，header，媒体类型来映射请求。这个注解既可以用在类级别，也可以用在方法级别上。<br>为了方便<code>@RequestMapping</code>根据HTTP方法不同提供了如下快捷注解：</p>
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@DeleteMapping</li>
<li>@PutMapping</li>
<li>@PatchMapping</li>
</ul>
<p>示例如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/persons"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PostMapping</span></div><div class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(@RequestBody Person person)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="URI-模式"><a href="#URI-模式" class="headerlink" title="URI 模式"></a>URI 模式</h5><p>请求映射支持glob模式和通配符</p>
<ul>
<li><code>?</code> 匹配一个字符</li>
<li><code>*</code> 匹配0个或多个字符</li>
<li><code>**</code> 匹配0个或多个路径<br>可以通过<code>@PathVariable</code> 访问在URI中定义的变量：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">findPet</span><span class="params">(@PathVariable Long ownerId, @PathVariable Long petId)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">URI的变量可以在类和方法中定义：</div><div class="line">```Java</div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/pets/&#123;petId&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">findPet</span><span class="params">(@PathVariable Long ownerId, @PathVariable Long petId)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>URI变量会自动类型转换，如果失败会抛出<code>TypeMismatchException</code>的异常。默认支持<code>int</code>,<code>long</code>,<code>Date</code>等类型，也可以通过DataBinder和 Type Conversion来注册其他需要支持的类型。<br>URI变量名也可以明确的支持，例如<code>@PathVariable(&quot;customId&quot;)</code>，不过如果在编译的时候带着调试信息，或者对于Java8 使用<code>-parameters</code> 编译，则可以不需要明确的命名。<br>语法<code>{varName:regex}</code>表示变量根据正则表达是来匹配，例如”/spring-web-3.0.5 .jar”可以使用以下表达式匹配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@PathVariable String version, @PathVariable String ext)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>URI同样可以有内嵌的<code>${}</code>的占位符，在应用启动的时候由<code>PropertyPlaceHolderConfigurer</code>从本地，系统，环境变量或者其他配置中解析。<br>Spring MVC使用的是Spring core 中的<code>AntPathMatcher</code>来匹配路径。</p>
<h5 id="模式对比"><a href="#模式对比" class="headerlink" title="模式对比"></a>模式对比</h5><p>当有很多模式匹配URI的时候，必须通过对比来找到最合适的匹配。这个是通过<code>AntPathMatcher.getPatternComparator(String path)</code>来实现。<br>可以根据URI中的变量个数，通配符个数来给URL打分，如果一个URI的变量少，通配符多，那么他得到的分数就会低。当匹配的模式分数相同是，选择匹配模式长的那个，如果分数和长度都相同，选择变量比通配符少的那个。<br><code>/**</code>是不参与评分的，而且总会是最后一个选择。同样<code>/plublic/**</code>也是当匹配不到其他没有两个通配符的模式的时候才会被选择。<br>了解更加详细的信息可以查看<code>AntPathMatcher</code>中的<code>AntPatternComparator</code>。同时也可个继承<code>PathMatcher</code>来定制URI匹配。</p>
<h5 id="后缀匹配"><a href="#后缀匹配" class="headerlink" title="后缀匹配"></a>后缀匹配</h5><p>Spring MVC 默认启动<code>.*</code>后缀匹配模式，这样映射到<code>/person</code>的controller 同样可以映射到<code>/person.*</code>。扩展名可以用来代替header中的<code>Accept</code>表示请求返回的类型。例如<code>person.pdf</code>,<code>person.xml</code>等。<br>因为过去浏览器的<code>Accept</code>头很难解析，所以这么是有意要的，但是现在浏览器的<code>Accept</code>更加清晰明确了，所以更好的选择是用<code>Accept</code>。而且过去一段时间内，使用后缀名匹配的时候会有各种各样的问题，当使用URI变量，路径参数，URI编码时后缀模式会导致歧义。<br>可以使用以下方法关闭后缀模式：</p>
<ul>
<li><code>PathMatchConfigurer</code>的<code>useSuffixPatternMatching(false)</code></li>
<li><code>ContentNeogiationConfigurer</code> 的<code>favorPathExtension(false)</code><h5 id="后缀匹配和RFD"><a href="#后缀匹配和RFD" class="headerlink" title="后缀匹配和RFD"></a>后缀匹配和RFD</h5>反射型文件下载(RFD)攻击和XSS攻击很相似。XSS依赖于请求的输入，例如查询参数，URI变量等，而RFD是用户点击URL浏览器会下载恶意文件，用户点击后会攻击主机。<br>由于Spring MVC的 <code>@ResponseBody</code>和<code>ResponseEntity</code>会根据URI后缀来渲染不同类型的响应内容，所以可能受到RFD攻击。关闭后缀匹配可以降低攻击的风险，但是不能完全防止RFD攻击。<br>为了防止RFD攻击，可以在渲染响应内容的时候添加<code>Content-Disposition:inline;filename=f.txt</code>确保一个安全的下载文件。<br>默认情况下大多数扩展名都有白名单，可以通过继承<code>HttpMessageConverter</code>对内容协商注册扩展，可以避免在响应中添加<code>Content-Disposition</code>。<h5 id="可消费媒体类型"><a href="#可消费媒体类型" class="headerlink" title="可消费媒体类型"></a>可消费媒体类型</h5>通过请求的<code>Content-Type</code>可以缩小请求的匹配范围，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostMapping</span>(path = <span class="string">"/pets"</span>, consumes = <span class="string">"application/json"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPet</span><span class="params">(@RequestBody Pet pet)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>consumes也支持表达式求反操作，例如<code>!text/plain</code>指的就除了<code>text/plain</code>都可以。<br>可以定义一个类级别的consumes，其方法共享这个consumes，和其他的<code>@ReqeustMapping</code>的属性不同，方法的consumes会覆盖类的定义。</p>
<h5 id="可产生的媒体类型"><a href="#可产生的媒体类型" class="headerlink" title="可产生的媒体类型"></a>可产生的媒体类型</h5><p>可以通过<code>Accept</code>头来缩小请求的匹配范围，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets/&#123;petId&#125;"</span>, produces = <span class="string">"application/json;charset=UTF-8"</span>)</div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>媒体类型可以指定一个字符集。对表达式取反也是支持的，例如：<code>!text/plain</code>指的就是除了<code>text/plain</code>都可以。<br>和consumes一样，也可以指定一个类级别的produces，其方法属性也会覆盖类的属性。</p>
<h5 id="参数和HTTP-header"><a href="#参数和HTTP-header" class="headerlink" title="参数和HTTP header"></a>参数和HTTP header</h5><p>可以通过参数来缩小请求匹配的范围。可以设置是否有参数(“myParam”),反过来是否没有(“!myParam”)或者指定一个值（”myParam=myValue”)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets/&#123;petId&#125;"</span>, params = <span class="string">"myParam=myValue"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样的情况也适合HTTP header<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets"</span>, headers = <span class="string">"myHeader=myValue"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2018/04/10/spring-mvc-controller/" data-id="cjg4tbp50001nu7r80jthv3ce" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2018/04/10/spring-mvc-controller/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringMVC/">SpringMVC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring-mvc-dispatcher-servlet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/09/spring-mvc-dispatcher-servlet/" class="article-date">
  <time datetime="2018-04-08T16:39:10.000Z" itemprop="datePublished">2018-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/09/spring-mvc-dispatcher-servlet/">SpringMVC 教程 - DispatcherServlet</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>同许多其他的web框架一样，SpringMVC使用了前端控制器的设计模式，即一个以<code>DispatcherServlet</code>为核心的<code>Servlet</code>为处理请求提供了一个共享的算法，而实际的工作是由可配置的委托组件执行的。这个模式即灵活又支持多样的工作流。<br>同其他的<code>Servlet</code>,依照Servlet 规范<code>DispatcherServlet</code>需要在web.xml或者Java配置中声明并映射URL。接着<code>DispatcherServlet</code>使用Spring的配置来查找委托组件，用来映射URL，解析视图，异常处理等。<br>下面这个示例是使用Java配置来注册并初始化<code>DispatcherServlet</code>，这个类由Servlet容器自动发现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletCxt)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Load Spring web application configuration</span></div><div class="line">        AnnotationConfigWebApplicationContext ac = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</div><div class="line">        ac.register(AppConfig.class);</div><div class="line">        ac.refresh();</div><div class="line"></div><div class="line">        <span class="comment">// Create and register the DispatcherServlet</span></div><div class="line">        DispatcherServlet servlet = <span class="keyword">new</span> DispatcherServlet(ac);</div><div class="line">        ServletRegistration.Dynamic registration = servletCxt.addServlet(<span class="string">"app"</span>, servlet);</div><div class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</div><div class="line">        registration.addMapping(<span class="string">"/app/*"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面这个示例是使用<code>web.xml</code>来注册并初始化的<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h5><p><code>DispatcherServlet</code>需要一个扩展了的<code>ApplicationContext</code>的<code>WebApplicationContext</code>来配置自己的信息。<code>WebApplicationContext</code>包含了<code>Servlet</code>的<code>ServletContext</code>的引用，可以使用<code>RequestContextUtils</code>中的静态方法从<code>WebApplicationContext</code>中查找<code>ServletContext</code>。<br>对于大多数应用来说一个<code>WebApplicationContext</code>就足够了。当然<code>WebApplicatioContext</code>也可以是有层次结构的，例如由多个Servlet共享的一个根<code>WebApplicationContext</code>，每个Servlet又有自己的子<code>WebApplicationContext</code>。<br>根<code>WebApplicationContext</code>一般包括需要在多个Servlet中共享的基础bean，例如数据仓库，业务逻辑等。在Servlet规范中，这些bean可以被有效的继承和改写，子<code>WebApplicationContext</code>仅包含在其属于的Servlet中。<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/mvc-context-hierarchy.png" alt="spring mvc context"><br>下面这个例子就是<code>WebApplicationContext</code>的层级配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; RootConfig.class &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; App1Config.class &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/app1/*"</span> &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样的，在web.xml中的配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app1-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app1/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="特殊的bean类型"><a href="#特殊的bean类型" class="headerlink" title="特殊的bean类型"></a>特殊的bean类型</h5><p><code>DispatcherServlet</code>委托专用的bean来处理请求，渲染响应。专用的bean指的是Spring管理的，实现WebFlux框架约定的实例。这些bean一般都是内建的约定，但是可以定制他们的属性，扩展或者代替这些bean。</p>
<table>
<thead>
<tr>
<th style="text-align:left">bean 类型</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HandlerMapping</td>
<td style="text-align:left">处理器映射，具体由其子类实现。两个重要的子类，<code>RequestMappingHandlerMapping</code>,<code>SimpleUrlHandlerMapping</code></td>
</tr>
<tr>
<td style="text-align:left">HandlerAdapter</td>
<td style="text-align:left">辅助<code>DispatcherServlet</code>执行特定的处理器。</td>
</tr>
<tr>
<td style="text-align:left">HandlerExceptionResolver</td>
<td style="text-align:left">将异常重定向到其他处理器或者是显示HTML的错误界面。</td>
</tr>
<tr>
<td style="text-align:left">ViewResolver</td>
<td style="text-align:left">通过处理器返回的视图字符串查找具体的视图并渲染。 </td>
</tr>
<tr>
<td style="text-align:left">LocaleResolver, LocaleContextResolver</td>
<td style="text-align:left">支持国际化页面，使用例如时区等来解析本地化问题。 </td>
</tr>
<tr>
<td style="text-align:left">ThemeResolver</td>
<td style="text-align:left">解析应用可用的主题，例如提供个性化框架 </td>
</tr>
<tr>
<td style="text-align:left">MultipartResolver</td>
<td style="text-align:left">处理上传文件 </td>
</tr>
<tr>
<td style="text-align:left">FlashMapManager</td>
<td style="text-align:left">保存和检索输入输出的FlashMap，它可以将属性从一个请求传递到另一个请求的输入输出，一般应用在重定向中。 </td>
</tr>
</tbody>
</table>
<h5 id="Web-MVC-配置"><a href="#Web-MVC-配置" class="headerlink" title="Web MVC 配置"></a>Web MVC 配置</h5><p>应用可以声明在特殊的bean类型中列出的bean来处理请求。<code>DispatcherServlet</code>会检查每一个bean的<code>WebApplicationContext</code>。如果没有指定的bean，那么就会使用DispatcherServlet.properties中定义的bean。<br>MVC配置将会在以后详细的列出。</p>
<h5 id="Servlet-配置"><a href="#Servlet-配置" class="headerlink" title="Servlet 配置"></a>Servlet 配置</h5><p>在Servlet 3.0+中，可以使用编程的方式来代替web.xml配置。下面这个例子就是通过编程注册<code>DispatcherServlet</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</div><div class="line">        XmlWebApplicationContext appContext = <span class="keyword">new</span> XmlWebApplicationContext();</div><div class="line">        appContext.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</div><div class="line"></div><div class="line">        ServletRegistration.Dynamic registration = container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet(appContext));</div><div class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</div><div class="line">        registration.addMapping(<span class="string">"/"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>WebApplicationInitializer</code>是由SpringMVC提供的接口，用来保证上述实现可以由支持Servlet 3.0的容器自动检测并初始化。抽象类<code>AbstractDispatcherServletInitializerl</code>实现了<code>WebApplicationInitializer</code> 可以更加容易的注册<code>DispathcerServlet</code>。<br>下面是使用Java配置的Spring<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; MyWebConfig.class &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用的是xml配置，需要直接继承<code>AbstractDispatcherServletInitializer</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createServletApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        XmlWebApplicationContext cxt = <span class="keyword">new</span> XmlWebApplicationContext();</div><div class="line">        cxt.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</div><div class="line">        <span class="keyword">return</span> cxt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>AbstractDispatcherServletInitializer</code>同样提供了一个方便的函数来添加过滤器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filter[] &#123;</div><div class="line">            <span class="keyword">new</span> HiddenHttpMethodFilter(), <span class="keyword">new</span> CharacterEncodingFilter() &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个过滤器根据他具体的类型添加一个默认的名字，并且自动映射到DispatcherServlet。<br><code>isAsyncSupported</code>方法是<code>AbstractDispatcherServletInitializer</code>的protect的方法，可以启动<code>DispatcherServlet</code>支持异步处理<br>如果要定义自己的DispatcherServlet，那么可以重写<code>createDispatcherServlet</code>方法。</p>
<h5 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h5><p><code>DispatcherServlet</code>处理请求的流程如下：  </p>
<ul>
<li>查找<code>WebApplicationContext</code>并将其作为request的一个属性保存起来，以便其他控制器或者处理链中的组件可以使用。默认保存键为<code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> </li>
<li>本地化解析器保存在request中，以便处理链中的其他组件使用他来处理请求做本地化处理。如果不需要本地化，那么就不需要使用他。</li>
<li>主题解析器保存在request中，以便其他组件，例如视图查找器使用，如果不需要要主题定制，直接忽略。</li>
<li>如果指定了文件上传解析器，那么就会检查请求是否有文件上传，如果有请求有<code>MultipartHttpServletRequest</code>封装，以便其他组件处理。</li>
<li>查找合适的处理器处理请求。如果找到了处理器，那么就依次执行处理链上的组件，返回一个model或者视图。如果是注解的controller也可以直接渲染而不需要返回视图。</li>
<li>如果返回一个model，会渲染一个视图，如果没有返回model，那么就无需渲染视图了，因为视图可能已经被渲染了。</li>
</ul>
<p>在请求处理过程中如果出现了一场那么就可以使用<code>WebApplicatioContext</code>中的<code>HandlerExceptionResolver</code>来定制异常处理。<br>SpringMVC 同样支持返回<code>last-modification-date</code>，对指定请求处理如何判断是否有<code>last-modification-date</code>非常直接：<code>DispatcherServlet</code>查找适合的处理器，并且检查其是否实现了<code>LastModified</code>接口，如果实现了，调用<code>long getLastModified(request)</code>返回给客户端。<br>通过web.xml中Servlet的初始化参数可以定制DispatcherServlet.</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">contextClass</td>
<td style="text-align:left">实现<code>WebApplicationContext</code>的类，默认使用<code>XmlWebApplicationContext</code> </td>
</tr>
<tr>
<td style="text-align:left">contextConfigLocation</td>
<td style="text-align:left">传递给Context 实例的字符串，包括了bean的定义 </td>
</tr>
<tr>
<td style="text-align:left">namespace</td>
<td style="text-align:left"><code>WebApplicationContext</code> 的命名空间，默认<code>[servlet-name]-servlet</code> </td>
</tr>
</tbody>
</table>
<h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><p><code>HandlerMapping</code>支持拦截器，在对某些请求添加处理的时候非常有用，比如，权限检查。拦截器必须实现<code>org.springframework.web.servlet</code>包中的<code>HandlerInterceptor</code>，这个接口有三个处理函数分别对应请求处理前，请求处理后，完成请求处理。</p>
<ul>
<li>preHandle(..) 在请求处理前执行</li>
<li>postHandle(..) 请求处理后执行</li>
<li>afterCompletion(..) 整个请求处理结束后执行<br><code>preHandle(..)</code> 返回一个boolean值。可以使用这个值来中断处理请求链。当返回true的时候，处理将会继续执行，如果返回false，<code>DispatcherServelt</code>假定拦截器已经对请求正确处理了，例如渲染了一个页面等。将会中断请求处理链。<br>注意，<code>postHandle</code>方法很少使用<code>@ResponseBody</code>和<code>ResponseEntity</code>。因为响应已经在<code>postHandle</code>执行之前有<code>HandlerAdapter</code>返回了。意味着在<code>postHandle</code>的时候再修改响应已经晚了。对应这种场景可以继承<code>ResponseBodyAdvice</code>或者实现ControllerAdvice或者直接配置<code>RequestMappingHandlerAdapter</code>来实现。</li>
</ul>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>如果在请求映射或者处理请求的时候抛出异常，<code>DispatcherServelt</code>会委托<code>HandlerExceptionResolver</code>来解析异常并提供可选择的处理，即返一个错误响应。<br>下表是<code>HandlerExceptionResolver</code>的实现</p>
<table>
<thead>
<tr>
<th style="text-align:left">HandlerExceptionResolver</th>
<th style="text-align:left">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SimpleMappingExceptionResolver</td>
<td style="text-align:left">异常类名和错误页面名的映射。浏览器渲染错误页面的时候非常实用 </td>
</tr>
<tr>
<td style="text-align:left">DefaultHandlerExceptionResolver</td>
<td style="text-align:left">解析SpringMVC抛出的异常，同时将其映射到HTTP的错误码上  </td>
</tr>
<tr>
<td style="text-align:left">ResponseStatusExceptionResolver</td>
<td style="text-align:left">解析@ResponseStatus注解，同时根据其注解值将其映射到HTTP的错误码上  </td>
</tr>
<tr>
<td style="text-align:left">ExceptionHandlerExceptionResolver</td>
<td style="text-align:left">调用@Controller 或者@ControllerAdvice 类中使用@ExceptionHandler注解的方法 </td>
</tr>
</tbody>
</table>
<h6 id="解析链"><a href="#解析链" class="headerlink" title="解析链"></a>解析链</h6><p>可以通过在Spring的配置中声明多个<code>HandlerExceptionResolver</code>bean，来构成一个异常处理解析链，如果需要的话，同时可以设置他们解析的顺序。序号越大，处理越靠后。<br><code>HandlerExceptionResolver</code>可以返回：</p>
<ul>
<li>指向错误页面的 <code>ModelAndView</code></li>
<li>如果异常在解析链中被处理返回空<code>ModelAndView</code></li>
<li>如果异常为被处理返回<code>null</code>，后续的解析起继续处理异常，如果异常一直未被处理，那么将会冒泡到Servlet容器处理<br>Spring MVC的异常是有MVC配置自动声明的，@ResponseStatus注解异常，支持@ExceptionHandler方法的异常。这些处理器都是可以定制和替换的<h6 id="Servlet容器异常"><a href="#Servlet容器异常" class="headerlink" title="Servlet容器异常"></a>Servlet容器异常</h6>如果<code>HandlerExceptionResolver</code>无法处理异常，那么异常将会继续传播，或者是返回了错误的HTTP状态码，例如4xx，5xx。Servlet容器可能会渲染一个错误的页面。这个页面也是可以定制的：<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>根据上述代码，当出现了无法处理的异常，或者返回错误码，容器会根据配置返回一个错误的URL。这个请求将会继续被DispatcherServlet处理，比如映射到一个@Controller的错误处理控制器上：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/error"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">handle</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">        map.put(<span class="string">"status"</span>, request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>));</div><div class="line">        map.put(<span class="string">"reason"</span>, request.getAttribute(<span class="string">"javax.servlet.error.message"</span>));</div><div class="line">        <span class="keyword">return</span> map;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="视图解析"><a href="#视图解析" class="headerlink" title="视图解析"></a>视图解析</h5><p>Spring MVC通过定义了<code>ViewResolver</code>和<code>View</code>两个接口可以让我们直接通过返回model来渲染视图，而不需要指定某一个特定的视图技术。<code>ViewResolver</code>提供了视图名和视图之间的映射关系。在提交给特定视图技术之前由<code>View</code>来准备数据。<br>下列表格展示了ViewResolver的层级：</p>
<table>
<thead>
<tr>
<th style="text-align:left">ViewResolver</th>
<th style="text-align:left">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AbstractCachingViewResolver</td>
<td style="text-align:left">缓存解析过的视图。可设置cache属性为false来关闭缓存。在需要刷新缓存的场景可调用<code>removeFromCache(String viewName, Locale loc)</code>刷新。</td>
</tr>
<tr>
<td style="text-align:left">XmlViewResolver</td>
<td style="text-align:left">实现<code>ViewResolver</code>，可以接收一个同Spring XML bean同DTD的xml配置文件。默认在/WEB-INF/views.xml</td>
</tr>
<tr>
<td style="text-align:left">ResourceBundleViewResolver</td>
<td style="text-align:left">解析定义在<code>ResourceBundle</code>中的视图，使用viewname.class作为视图类，viewname.url作为视图名</td>
</tr>
<tr>
<td style="text-align:left">UrlBasedViewResolver</td>
<td style="text-align:left">无需明确指定映射，直接通过解析url来查找视图名。</td>
</tr>
<tr>
<td style="text-align:left">InternalResourceViewResolver</td>
<td style="text-align:left">实现<code>UrlBasedViewResolver</code>,<code>JstlView</code>,<code>TilesView</code>，支持<code>InternalResourceView</code>例如：jsp，servlet class等。</td>
</tr>
<tr>
<td style="text-align:left">FreeMarkerViewResolver</td>
<td style="text-align:left"><code>UrlBasedViewResolver</code>的子类，用来支持FreeMarker</td>
</tr>
<tr>
<td style="text-align:left">ContentNegotiatingViewResolver</td>
<td style="text-align:left">根据请求的文件名或者Accept来确定视图</td>
</tr>
</tbody>
</table>
<h6 id="视图处理"><a href="#视图处理" class="headerlink" title="视图处理"></a>视图处理</h6><p>如果需要的话，可以声明多个视图处理器，通过设置<code>order</code>属性来确定他们的顺序。order越大，处理越靠后。<br>默认情况下<code>ViewResolver</code>可以返回null代表找不到视图。当然在JSP中，使用InternalResourceViewResolver来检查JSP是否存在的唯一方式就是通过<code>RequestDispatcher</code>执行一次调度。因此<code>InternalResourceViewResolver</code>必须是最后一个视图解析器。</p>
<h6 id="视图redirect"><a href="#视图redirect" class="headerlink" title="视图redirect"></a>视图redirect</h6><p>视图前缀<code>redirect:</code> 表示视图需要执行一次redirect。<code>UrlBasedViewResolver</code>和其子类会识别出这是要给重定向，剩下的部分就是视图名。<br>这个效果和Controller返回一个<code>RedirectView</code>一样，但是使用这个指令，controller就可以简单的返回一个视图名就可以了。视图名<code>redirect:/myapp/some/resource</code>将会返回相对于当前Servlet Context的视图，<code>redirect:http://myhost.com/some/arbitrary/path</code> 这种则会返回绝对URL。<br>注意，如果一个controller被<code>@ResponseStatus</code>修饰，那么注解值优先级高于<code>RedirectView</code></p>
<h6 id="视图Forwarding"><a href="#视图Forwarding" class="headerlink" title="视图Forwarding"></a>视图Forwarding</h6><p>视图前缀<code>forward:</code>表示视图执行forwarding。同样由<code>UrlBasedViewResolver</code>和其子类解析。通过创建<code>InternalResourceView</code>执行<code>RequestDispatcher.forward()</code>实现。因此这个指令对于<code>InternalResourceViewResolver</code>和<code>InternalResourceViewResolver</code>没啥用，但是对于使用了其他的视图技术但是仍然想用强制使用JSP或者Servlet的时候就很有用了。</p>
<h6 id="视图内容协商"><a href="#视图内容协商" class="headerlink" title="视图内容协商"></a>视图内容协商</h6><p><code>ContentNegotiatingViewResolver</code>并不会解析视图，而是将其委托给其他视图解析器，并且选择客户端请求描述选择视图。描述可以是Accept头或者参数，例如<code>/path?format=pdf</code><br><code>ContentNegotiatingViewResolver</code>通过对比请求的媒体类型和<code>ViewResolvers</code>支持的媒体类型来选择合适的View。被选中的列表中的第一个View将会被返回给客户端。</p>
<h5 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h5><p>同Spring MVC，大多数Spring架构支持国际化。<code>DispatcherServlet</code>通过<code>LocaleResolver</code>根据客户端的区域自动解析消息。<br>当请求到来时<code>DispatcherServlet</code>查找本地化解析器，如果找到则会设置本地化。通过<code>RequestContext.getLocale()</code>方法可以获取由本地化解析器解析的本地化语言。<br>为了自动化解析，可以通过拦截器对具体的场景进行本地化解析，例如根据请求参数来解析。<br>本地化解析器和拦截器定义在<code>org.springframework.web.servlet.i18n</code>包中，可以在应用中配置。下面是一些Spring使用的配置</p>
<h6 id="TimeZone"><a href="#TimeZone" class="headerlink" title="TimeZone"></a>TimeZone</h6><p>通过获取客户端的时区来做本地化。<code>LocaleContextResolver</code>接口扩展了<code>LocalResolver</code>，提供了一个可能包含时区信息的<code>LocaleContext</code>。<br>如果可以，用户的时区可以通过<code>RequestContext.getTimeZone()</code>方法获取。时区信息可以自动的被注册到Spring中的ConversionService 日期时间的Converter和Formatter使用。</p>
<h6 id="Header-resolver"><a href="#Header-resolver" class="headerlink" title="Header resolver"></a>Header resolver</h6><p>这个解析器检查<code>accept-language</code>头，一般来说包含的是客户端操作系统的区域。注意这个不支持时区。</p>
<h6 id="Cookie-resolver"><a href="#Cookie-resolver" class="headerlink" title="Cookie resolver"></a>Cookie resolver</h6><p>这个解析器检查cookie中可能包含的<code>TimeZone</code>和<code>Locale</code>。通过如下定义来使用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookieName"</span> <span class="attr">value</span>=<span class="string">"clientlanguage"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookieMaxAge"</span> <span class="attr">value</span>=<span class="string">"100000"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>CookieLocaleResolver的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cookieName</td>
<td style="text-align:left">classname + LOCALE</td>
<td style="text-align:left">cookie名</td>
</tr>
<tr>
<td style="text-align:left">cookieMaxAge</td>
<td style="text-align:left">Servlet容器默认值</td>
<td style="text-align:left">cookie生效时间</td>
</tr>
<tr>
<td style="text-align:left">cookiePath</td>
<td style="text-align:left">/</td>
<td style="text-align:left">cookie 保存位置</td>
</tr>
</tbody>
</table>
<h6 id="Session-resolver"><a href="#Session-resolver" class="headerlink" title="Session resolver"></a>Session resolver</h6><p><code>SessionLocaleResolver</code>通过从session中检查可能包含的<code>TimeZone</code>和<code>Locale</code>。相对于<code>CookieLocaleResolver</code>，他将信息保存在<code>HttpSession</code>中。</p>
<h6 id="Locale-interceptor"><a href="#Locale-interceptor" class="headerlink" title="Locale interceptor"></a>Locale interceptor</h6><p>可以通过拦截器启动针对某些映射的本地化策略，例如如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeChangeInterceptor"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"paramName"</span> <span class="attr">value</span>=<span class="string">"siteLanguage"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"urlMapping"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptors"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"localeChangeInterceptor"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/**/*.view=someController<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h5><p>可以通过设置Spring MVC的主题来整体设置应用的外观，从而提高用户体验。主题是一些静态资源的集合，主要是可以影响外观的样式表和图片。<br>为了应用主题，首先要设置一个<code>org.springframework.ui.context.ThemeSource</code>的接口。<code>WebApplicationContext</code>继承了<code>ThemeSource</code>，但是将其实现委托给了子类。默认使用的是<code>org.springframework.ui.context.support.ResourceBundleThemeSource</code>来从classpath的根目录下加载配置文件。配置文件格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">styleSheet=/themes/cool/style.css</div><div class="line">background=/themes/cool/img/coolBg.jpg</div></pre></td></tr></table></figure></p>
<p>配置文件的名字是视图代码中的变量名。对于JSP而言可以如下显示：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;link rel="stylesheet" href="&lt;spring:theme code='styleSheet'/&gt;" type="text/css"/&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body style="background=&lt;spring:theme code='background'/&gt;"&gt;</div><div class="line">        ...</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>默认情况下<code>ResourceBundleThemeSource</code>使用空的前缀名，这样配置文件直接从classpath根目录下加载。这样就可以将<code>cool.properties</code>定义放到classpath根目录下，<code>ResourceBundleThemeSource</code>默认使用标准的Java资源加载工具，同时也完全支持国际化，所以通过命名来支持<code>cool_nl.properties</code>。</p>
<h6 id="解析主题"><a href="#解析主题" class="headerlink" title="解析主题"></a>解析主题</h6><p><code>DispatcherServlet</code>通过bean的名字<code>themeResolver</code>来查找<code>ThemeResolver</code>的实现。<br>ThemeResolver 的实现如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Class</th>
<th style="text-align:left">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FixedThemeResolver</td>
<td style="text-align:left">选中一个固定的主题，设置<code>defaultThemeName</code>属性</td>
</tr>
<tr>
<td style="text-align:left">SessionThemeResolver</td>
<td style="text-align:left">主题由用户session维护。每个session只需要设置一次</td>
</tr>
<tr>
<td style="text-align:left">CookieThemeResolver</td>
<td style="text-align:left">通过cookie选择主题</td>
</tr>
</tbody>
</table>
<h5 id="Multipart-resolver"><a href="#Multipart-resolver" class="headerlink" title="Multipart resolver"></a>Multipart resolver</h5><p><code>org.springframework.web.multipart</code>中的<code>MultipartResolver</code>是用来处理multipart请求的。共有给予Common Fileupload和Servlet 3.0 两种实现。<br>为了使用multipart，需要在<code>DispatcherServlet</code>的Spring配置中声明一个名字为<code>multipartResolver</code>的bean。当POST请求的<code>content-type</code>是<code>multipart/form-data</code>的时候，解析器解析这个请求并且将<code>HttpServletRequest</code>封装成<code>MultipartHttpServletRequest</code>来处理请求。</p>
<h6 id="Apache-FileUpload"><a href="#Apache-FileUpload" class="headerlink" title="Apache FileUpload"></a>Apache FileUpload</h6><p>使用Apache Commons FileUpload 只需要简单的配置一个类型为<code>CommonsMultipartResolver</code>，名字为<code>multipartResolver</code>的bean即可。当然也需要将<code>commons-fileupload</code>加入到依赖中。</p>
<h6 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a>Servlet 3.0</h6><p>使用Servlet 3.0则需要Servlet 容器的配置</p>
<ul>
<li>使用Java配置，在Servlet注册中设置<code>MultipartConfigElement</code>。</li>
<li>使用web.xml 添加要给<code>&lt;multipart-config&gt;</code>的配置<br>如下是使用Java的配置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold</span></div><div class="line">        registration.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(<span class="string">"/tmp"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Servlet 3.0配置好之后，只需要添加类型为<code>StandardServletMultipartResolver</code>，名字为<code>multipartResolver</code>的配置即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2018/04/09/spring-mvc-dispatcher-servlet/" data-id="cjg4tbp4w001ku7r838qbzgt9" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2018/04/09/spring-mvc-dispatcher-servlet/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringMVC/">SpringMVC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring-mvc-filter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/09/spring-mvc-filter/" class="article-date">
  <time datetime="2018-04-08T16:39:10.000Z" itemprop="datePublished">2018-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/09/spring-mvc-filter/">SpringMVC 教程 - Filter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><code>spring-web</code>模块提供了许多非常实用的Filter</p>
<h5 id="HTTP-PUT-FORM"><a href="#HTTP-PUT-FORM" class="headerlink" title="HTTP PUT FORM"></a>HTTP PUT FORM</h5><p>浏览器只能通过GET或者POST提交FORM数据，但是非浏览器的客户端可以使用PUT或者PATCH。Servlet API仅为POST方法提供了<code>ServletRequest.getParameter*()</code>方法获取FORM信息。<br><code>spring-web</code>模块提供了<code>HttpPutFormContentFilter</code>检查PUT或者PATCH方法的<code>content-type</code>是否是<code>application/x-www-form-urlencoded</code>,如果是，则从请求体重读取属性并封装到<code>ServletRequest</code>中，以便日后通过<code>ServletRequest.getParameter*()</code>获取FORM数据。</p>
<h5 id="重定向头"><a href="#重定向头" class="headerlink" title="重定向头"></a>重定向头</h5><p>由于请求会经过像负载均衡器这样的代理，那么host，port，scheme在创建一些资源文件的链接的时候返回给客户端可能是有所不同的。<br>RFC 7239 为代理定义了<code>Forwarded</code> 的HTTP头来提供原始请求的信息。同样也有一些其他非标准的HTTP头，例如：<code>X-Forwarded-Host</code>,<code>X-Forwarded-Port</code>,<code>X-Forwarded-Proto</code>。<br><code>ForwardedHeaderFilter</code>会从<code>Forwarded</code>,<code>X-Forwarded-Host</code>,<code>X-Forwarded-Port</code>或者<code>X-Forwarded-Proto</code>中获取跳转信息。他分装了请求以覆盖host，port，scheme，同样为日后的处理隐藏跳转信息。<br>注意，根据RFC 7239第八节的解释，使用重定向头的时候会有安全问题。在应用层是无法判断一个挑战是否是可信的。所以要正确配置网络上游代理，以便过滤掉不合法的跳转。<br>如果应用没有使用代理，那么就无需使用<code>ForwardedHeaderFilter</code>过滤器。</p>
<h5 id="Shallow-ETag"><a href="#Shallow-ETag" class="headerlink" title="Shallow ETag"></a>Shallow ETag</h5><p><code>ShallowEtagHeaderFilter</code>为ETG提供了过滤器，关于ETAG将在视图技术中详细解释。</p>
<h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p>通过controller的注解Spring MVC对CORS提供了详细的支持。在和Spring Sercurity一同使用的时候<code>CorsFilter</code>必须排在Spring Sercurity的过滤器之前。</p>
<h5 id="关于CORS"><a href="#关于CORS" class="headerlink" title="关于CORS"></a>关于CORS</h5><p>由于安全原因，浏览器禁止AJAX跳出当前域去访问资源。例如你的银行帐号在一个tab页打卡了，另一个evil.com在其他tab打开。evil.com的脚本不能使用你的银行账号信息去访问银行的API。<br>Cross-Origin Resource Sharing (CORS) 是由众多浏览器实现的W3C的规范。他规定了允许哪些请求可以跨域，而不是通过弱安全的和功能受限的IFRAME和JSONP。<br><code>HandlerMapping</code>对CORS提供了内置支持。成功将请求映射到处理器后，<code>HandlerMapping</code>对当前请求检查CORS配置，预检请求直接处理，简单和实际请求则检查CORS请求，验证，设置返回header。<br>为了开启跨域请求（例如<code>Origin</code>头和请求的host不一致），需要对CORS进行明确的配置。如果没有找到CORS的配置，那么直接拒绝预检请求，简单请求和实际请求不会添加响应头，因此浏览器不会获取到信息。<br>每一个<code>HandlerMapping</code>都可以根据URL不同配置单独的 <code>CorsConfiguration</code>。一般来说应用会通过Java Config或者Xml 命名空间来配置单一，全局的CORS。<br><code>HandlerMapping</code>级别的全局CORS配置可以和handler级别的CORS合并。例如有注解的controller可以使用类或者方法级别的注解<code>@CrossOrigin</code>配置跨域。<br><code>@CrossOrigin</code>注解可以在controller层启动对请求的跨域检查，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/account"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@CrossOrigin</span></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">retrieve</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认情况下<code>@CrossOrigin</code>的作用如下：</p>
<ul>
<li>允许所有的域</li>
<li>允许所有header</li>
<li>允许controller映射的方法</li>
<li><code>allowedCredentials</code> 默认关闭</li>
<li><code>max-age</code>默认30分钟<br><code>@CrossOrigin</code>同样支持类级别：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CrossOrigin</span>(origins = <span class="string">"http://domain2.com"</span>, maxAge = <span class="number">3600</span>)</div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/account"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">retrieve</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>@CrossOrigin</code>同时可以在类和方法中使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CrossOrigin</span>(maxAge = <span class="number">3600</span>)</div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/account"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@CrossOrigin</span>(<span class="string">"http://domain2.com"</span>)</div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">retrieve</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过定义全局的CORS配置，来配合使用。全局的CORS配置可以通过Java Config或者XML的XNM命名空间来配置。<br>默认情况下全局的CORS配置：</p>
<ul>
<li>允许所有的域</li>
<li>允许所有的header</li>
<li>允许GET,HEAD，POST方法</li>
<li><code>allowedCredentials</code> 默认关闭</li>
<li><code>max-age</code>默认30分钟<br>使用Java配置CORS<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebMvc</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</div><div class="line"></div><div class="line">        registry.addMapping(<span class="string">"/api/**"</span>)</div><div class="line">            .allowedOrigins(<span class="string">"http://domain2.com"</span>)</div><div class="line">            .allowedMethods(<span class="string">"PUT"</span>, <span class="string">"DELETE"</span>)</div><div class="line">            .allowedHeaders(<span class="string">"header1"</span>, <span class="string">"header2"</span>, <span class="string">"header3"</span>)</div><div class="line">            .exposedHeaders(<span class="string">"header1"</span>, <span class="string">"header2"</span>)</div><div class="line">            .allowCredentials(<span class="keyword">true</span>).maxAge(<span class="number">3600</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Add more mappings...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用XML配置CORS<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mvc:cors</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/api/**"</span></span></div><div class="line">        <span class="attr">allowed-origins</span>=<span class="string">"http://domain1.com, http://domain2.com"</span></div><div class="line">        <span class="attr">allowed-methods</span>=<span class="string">"GET, PUT"</span></div><div class="line">        <span class="attr">allowed-headers</span>=<span class="string">"header1, header2, header3"</span></div><div class="line">        <span class="attr">exposed-headers</span>=<span class="string">"header1, header2"</span> <span class="attr">allow-credentials</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">max-age</span>=<span class="string">"123"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/resources/**"</span></span></div><div class="line">        <span class="attr">allowed-origins</span>=<span class="string">"http://domain1.com"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">mvc:cors</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>另外，也可以通过<code>CorsFilter</code>配置CORS。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</div><div class="line"></div><div class="line"><span class="comment">// Possibly...</span></div><div class="line"><span class="comment">// config.applyPermitDefaultValues()</span></div><div class="line"></div><div class="line">config.setAllowCredentials(<span class="keyword">true</span>);</div><div class="line">config.addAllowedOrigin(<span class="string">"http://domain1.com"</span>);</div><div class="line">config.addAllowedHeader(<span class="string">""</span>);</div><div class="line">config.addAllowedMethod(<span class="string">""</span>);</div><div class="line"></div><div class="line">UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</div><div class="line">source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</div><div class="line"></div><div class="line">CorsFilter filter = <span class="keyword">new</span> CorsFilter(source);</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2018/04/09/spring-mvc-filter/" data-id="cjg4tbp52001pu7r8kz2ulri0" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2018/04/09/spring-mvc-filter/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringMVC/">SpringMVC</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-8-key-application-metrics" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/07/8-key-application-metrics/" class="article-date">
  <time datetime="2018-04-06T16:39:10.000Z" itemprop="datePublished">2018-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/07/8-key-application-metrics/">8个关键的应用性能指标</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://stackify.com/application-performance-metrics/" target="_blank" rel="external">原文地址</a>  </p>
<h5 id="用户满意度-Apdex-分数"><a href="#用户满意度-Apdex-分数" class="headerlink" title="用户满意度/Apdex 分数"></a>用户满意度/Apdex 分数</h5><p>应用性能指数或者Apdex分数，已经变成追踪应用反应性能的工业标准。<br>通过定义指标：一个指定的web请求或者事务达到这个指标的时间是多久。<br>这些事务可以被分为满意（快），可容忍（慢），太慢，请求失败。可以用下面这个简单的数学公式来表示，分数范围从0到1.<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/img_58a9f75d0a12a.png" alt="apdex score"></p>
<h5 id="平均响应时间"><a href="#平均响应时间" class="headerlink" title="平均响应时间"></a>平均响应时间</h5><p>首先先说明一点，平均非常傻。非常推荐使用上述的用户满意度Apedx分数来追踪性能问题。平均响应时间有时仍然是一个有用的指标。</p>
<h5 id="错误率"><a href="#错误率" class="headerlink" title="错误率"></a>错误率</h5><p>最不想用户看到的就是错误。监控错误率是一个应用的重要性能指标。<br>主要有以下三种错误：</p>
<ul>
<li>HTTP 错误-web请求错误的个数</li>
<li>日志异常： 在应用中未处理的，打印出来的异常日志</li>
<li>抛出异常： 所有抛出的异常<h5 id="应用实例的个数"><a href="#应用实例的个数" class="headerlink" title="应用实例的个数"></a>应用实例的个数</h5>如果应用是部署在云上。那么就知道你的服务器/应用实例到底有多少在运行就很重要了。自动伸缩可以帮助应用按需伸缩同时也能在飞峰值时节省资源。<h5 id="请求率"><a href="#请求率" class="headerlink" title="请求率"></a>请求率</h5>了解你的应用接收了多少流量对你应用的成功有显著的影响。一般来说其他的性能指标都被流量的增加和减少所影响。<br>请求率可以很容易的和其他的性能指标结合起来显示出你的应用时如何动态扩展的。<br>监控请求率可以很好的监控峰值或者低谷。如果你有一个频繁访问的API，突然一点流量都没有了，那么这就需要小心了。<br>一个相似，但是略有不同的指标就是追踪并发用户量。<h5 id="应用和服务器CPU"><a href="#应用和服务器CPU" class="headerlink" title="应用和服务器CPU"></a>应用和服务器CPU</h5>如果CPU使用率特别高，那么应用肯定有性能问题。监控CPU使用是服务器和应用最基本也是最重要的指标。<br>几乎所有的服务器或者应用监控工具都能追踪CPU使用，同时提供告警。对每一台服务器追踪他们的CPU使用率是很重要的，同样重要的是追踪一个应用的一组CPU的使用率。<h5 id="应用可用性"><a href="#应用可用性" class="headerlink" title="应用可用性"></a>应用可用性</h5>监控应用是否在线和可用是一个关键的指标。<br>如果是一个Web应用，最简单的方式就是设置几个定时任务来检查HTTP，是否可用。<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5>如果使用的是Java相关语言，则需要注意垃圾回收器的效率。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2018/04/07/8-key-application-metrics/" data-id="cjg4tbp2z0004u7r8rdxyh9j2" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2018/04/07/8-key-application-metrics/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/APM/">APM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Performance/">Performance</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-deep-in-spring-mvc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/07/deep-in-spring-mvc/" class="article-date">
  <time datetime="2018-04-06T16:39:10.000Z" itemprop="datePublished">2018-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/07/deep-in-spring-mvc/">深入理解Spring MVC</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://stackify.com/spring-mvc/" target="_blank" rel="external">原文地址</a>  </p>
<h5 id="初始工程"><a href="#初始工程" class="headerlink" title="初始工程"></a>初始工程</h5><p>这篇文章中将使用最新的Spring Framework 5框架。主要关注的是Spring的经典Web技术栈，这套技术从最开始的Spring版本就开始支持，并且知道现在仍然是构建Spring Web应用的主要方式。<br>使用Spring Boot和其他starter来设置初始工程。xml配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h5><p>为了理解Spring Web MVC是如何工作的，可以先实现一个简单的Login功能的。创建一个由<code>@Controller</code>来修饰的类<code>InternalController</code>，这个类包含一个Get的映射。<br><code>hello()</code>函数没有参数。返回一个由Spring解释的视图名字的字符串。（在本例中是<code>login.html</code>）  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</div><div class="line"></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"login"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了处理用户登陆逻辑，创建另一个接受POST请求的带有Login数据的方法。然后根据处理结果返回成功或者失败页面。<br>注意，<code>login()</code>函数接受一个领域对象作为参数，返回的是<code>ModelAndView</code>对象。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(LoginData loginData)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (LOGIN.equals(loginData.getLogin()) </div><div class="line">      &amp;&amp; PASSWORD.equals(loginData.getPassword())) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"success"</span>, </div><div class="line">          Collections.singletonMap(<span class="string">"login"</span>, loginData.getLogin()));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"failure"</span>, </div><div class="line">          Collections.singletonMap(<span class="string">"login"</span>, loginData.getLogin()));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ModelAndView</code>保存了两个不同的对象：</p>
<ul>
<li>Model： 用来渲染页面用的键值对的map</li>
<li>View： 填充Model数据的模版页面。  </li>
</ul>
<p>将它们合并起来是为了方便，这样controller的方法就可以同时返回这两个了。<br>使用<code>Thymeleaf</code>作为模版引擎来渲染页面。  </p>
<h5 id="Java-Web应用的基础-Servlet"><a href="#Java-Web应用的基础-Servlet" class="headerlink" title="Java Web应用的基础-Servlet"></a>Java Web应用的基础-Servlet</h5><p>当你在浏览器里键入<code>http://localhost:8080/</code>，然后按回车键，请求到达服务器的时候到底发生了什么？是如何在浏览器中看到这个web请求的数据的？<br>因为这个项目是一个简单的Spring Boot应用，所以可以通过<code>Spring5Application</code>来运行。<br>Spring Boot默认使用<a href="http://stackify.com/tomcat-performance-monitoring/" target="_blank" rel="external">Apache Tomcat</a>运行程序，运行成功后可能会看到如下的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">2017-10-16 20:36:11.626  INFO 57414 --- [main] </div><div class="line">  o.s.b.w.embedded.tomcat.TomcatWebServer  : </div><div class="line">  Tomcat initialized with port(s): 8080 (http)</div><div class="line">  </div><div class="line">2017-10-16 20:36:11.634  INFO 57414 --- [main] </div><div class="line">  o.apache.catalina.core.StandardService   : </div><div class="line">  Starting service [Tomcat]</div><div class="line"></div><div class="line">2017-10-16 20:36:11.635  INFO 57414 --- [main] </div><div class="line">  org.apache.catalina.core.StandardEngine  : </div><div class="line">  Starting Servlet Engine: Apache Tomcat/8.5.23</div></pre></td></tr></table></figure>
<p>因为Tomcat是一个Servlet容器，所以几乎所有的HTTP请求都是由Java Servlet处理的。自然的Spring Web的入口就是一个Servlet。<br>Servlet是所有Java Web应用的核心组件；它非常的低成，并且没有暴露任何具体的编程模式，例如MVC。<br>一个HTTP的Servelt只能接受HTTP请求，处理请求后返回响应。<br>现在使用Servlet 3.0的API，可以不再使用XML配置，直接可以使用Java配置。</p>
<h5 id="Spring-MVC的核心-DispatcherServlet"><a href="#Spring-MVC的核心-DispatcherServlet" class="headerlink" title="Spring MVC的核心-DispatcherServlet"></a>Spring MVC的核心-DispatcherServlet</h5><p>作为Web开发者，我们希望抽象出以下枯燥和样板的任务，而关注于有用的业务逻辑  </p>
<ul>
<li>将HTTP请求映射到响应处理函数</li>
<li>将HTTP请求数据和header解析成数据传输对象（DTOs）或者领域对象</li>
<li>model-view-controller 互相交互</li>
<li>从DTO，领域对象等生成响应  </li>
</ul>
<p>Spring的<code>DispatcherServlet</code>提供了以上的功能，是Spring WEB MVC框架的核心，是应用接受所有请求的核心组件。<br>稍后就会了解到<code>DispatcherServlet</code>可扩展性非常强。例如：它允许你加入现有或者新的适配器来适应不同的任务：</p>
<ul>
<li>将请求映射到处理它的类或者函数(由<code>HandlerMapping</code>实现）</li>
<li>使用特定模式来处理请求，例如一个普通的Servlet，一个复杂的MVC 工作流，或者只是一个方法。(由<code>HandlerAdapter</code>实现）</li>
<li>通过名字解析试图对象，允许你使用不同的模版引擎，例如：XML，XSLT或者其他视图技术(由<code>ViewResolver</code>实现）</li>
<li>默认使用Apache Comons 的文件上传组件解析文件上传，或者也可以自己实现。</li>
<li>由<code>LocalResolver</code>实现本地化，包括cookie，session，HTTP的Accept Header，或者其他由用户定义的本地化。    </li>
</ul>
<h5 id="处理HTTP请求"><a href="#处理HTTP请求" class="headerlink" title="处理HTTP请求"></a>处理HTTP请求</h5><p>首先让我们重新审视一下在刚刚建立的应用中是如何处理HTTP请求的。<br><code>DispatcherServlet</code>有一个很长的继承层级。自顶向下理解每个单独的概念是非常有必要的。处理请求的函数将会更加有趣。<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/springmvc.png" alt="SpringMVC"><br>理解HTTP请求在本地开发模式处理和远程处理是理解MVC架构非常重要的一步。</p>
<h6 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h6><p><code>GenericServlet</code>时Servlet规范中的一部分，不直接处理HTTP。它定义了<code>service()</code>方法，来接受请求和返回响应。<br>注意，<code>ServletRequest</code>和<code>ServletResponse</code>并不是绑定到HTTP协议的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> </span></div><div class="line">  <span class="keyword">throws</span> ServletException, IOException;</div></pre></td></tr></table></figure></p>
<p>服务器所有的请求，包括简单的GET请求都会调用这个方法。</p>
<h5 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h5><p>正如其名，<code>HttpServelt</code>是Servlet 规范中关于HTTP请求的实现。<br>更确切的说，<code>HttpServlet</code>是一个实现了<code>service()</code>的抽象类。通过将不同的HTTP请求类型分开，由不同的函数处理，实现大约如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    String method = req.getMethod();</div><div class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        doGet(req, resp);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        doHead(req, resp);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</div><div class="line">        doPost(req, resp);</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h5 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h5><p>在这个继承关系中<code>HttpServletBean</code>是第一个Spring的类。从web.xml或者WebApplicationInitialzer获取的初始参数来注入bean。<br>在应用中的请求分别调用doGet,doPost等方法来处理不同的HTTP请求。</p>
<h5 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h5><p><code>FrameworkServlet</code>实现了<code>ApplicationContextAware</code>,集成Web的Application Context。不过它也可以创建自己的Application Context。<br>正如上述所言，父类<code>HttpServletBean</code>通过将初始参数作为bean的属性注入。因此如果contex的类名在<code>contextClass</code>这个初始参数中，那么就有这个参数创建application context的实例，否则默认使用<code>XmlWebApplicationContext</code>。<br>由于XML配置现在已经过时了。Spring Boot默认使用<code>AnnotationConfigWebApplicationContext</code>来配置<code>DispatcherServlet</code>。不过这个是很容易修改的。<br>例如，想要在Spring MVC中使用Groovy的application context，可以将下列配置在web.xml中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatcherServlet</div><div class="line">      org.springframework.web.servlet.DispatcherServlet</div><div class="line">      contextClass</div><div class="line">      org.springframework.web.context.support.GroovyWebApplicationContext</div></pre></td></tr></table></figure></p>
<p>相同的配置也可以在<code>WebApplicationInitializer</code>中配置。</p>
<h5 id="DispatcherServlet-统一处理请求"><a href="#DispatcherServlet-统一处理请求" class="headerlink" title="DispatcherServlet: 统一处理请求"></a>DispatcherServlet: 统一处理请求</h5><p><code>HttpServlet.service()</code>通过HTTP的动词类型来处理路由不同的请求到不同的方法，这个在底层的servlet实现的很好。但是，在SpringMVC的抽象层次中，不能仅靠方法类型来路由请求。<br>同样的，<code>FrameworkServlet</code>的另一个主要功能就是将不同的处理使用<code>processRequest()</code>组合在一起。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">  HttpServletResponse response) <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">    processRequest(request, response);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">  HttpServletResponse response) <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">    processRequest(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="DispatcherServlet-丰富请求"><a href="#DispatcherServlet-丰富请求" class="headerlink" title="DispatcherServlet: 丰富请求"></a>DispatcherServlet: 丰富请求</h5><p>最后,<code>DispatcherServlet</code>实现<code>doService()</code>方法。它向请求中加入了一些有用的对象，继续在web 的管道中传递下去，例如：web application context, locale resolver, theme resolver, theme source等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, </div><div class="line">  getWebApplicationContext());</div><div class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</div><div class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</div><div class="line">request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</div></pre></td></tr></table></figure></p>
<p>同时，<code>doService()</code>加入了输入输出的Flash Map，Flash Map是将参数从一个请求传递到另一个请求的基本模式。在重定向中很有用。(例如在重定向之后向用户展示一段简单的信息）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager</div><div class="line">  .retrieveAndUpdate(request, response);</div><div class="line"><span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</div><div class="line">    request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, </div><div class="line">      Collections.unmodifiableMap(inputFlashMap));</div><div class="line">&#125;</div><div class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</div></pre></td></tr></table></figure></p>
<p>接着<code>doService()</code>将会调用<code>doDispatch()</code>方法来分发请求。</p>
<h5 id="DispatcherServlet-分发请求"><a href="#DispatcherServlet-分发请求" class="headerlink" title="DispatcherServlet: 分发请求"></a>DispatcherServlet: 分发请求</h5><p><code>dispatch()</code>的主要目的就是知道一个合适的处理请求的处理器并且传递request/response参数。处理器可以是任何对象，并不局限于一个特定的接口。同样也意味着Spring需要找到如何使用这个处理器的适配器。<br>为了给请求找到合适的处理器，Spring会遍历实现<code>HandlerMapping</code>接口的注册的实现。有很多不同的实现可以满足我们各种需求。<br><code>SimpleUrlHandlerMapping</code>使用URL将请求映射到处理bean中。例如：它可以通过<code>Java.util.Properties</code>注入它的映射信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/welcome.html=ticketController</div><div class="line">/show.html=ticketController</div></pre></td></tr></table></figure></p>
<p><code>RequestMappingHandlerMapping</code>可能是最广泛使用的映射处理器。它将请求映射到<code>@Controller</code>类下的<code>@RequestMapping</code>修饰的方法上。这个就是上面那个例子中的<code>hello()</code>和<code>login()</code>。<br>注意，上面两个方法分别是<code>@GetMapping</code>和<code>@PostMapping</code>修饰的。这两个注解来源于<code>@RequestMapping</code>。<br><code>dispatch()</code>同时也可以处理一些其他的HTTP的任务：</p>
<ul>
<li>如果资源不存在，对GET请求进行短路处理。</li>
<li>对相应的请求使用multipart 解析。</li>
<li>如果处理器选择异步处理请求，对请求进行短路处理。  </li>
</ul>
<h5 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h5><p>现在Spring确定了处理请求的处理器和处理器的适配器，是时候处理请求了。下面是<code>HandlerAdapter.handle()</code>的签名。比较重要的一点是处理器可以选择如何处理请求：</p>
<ul>
<li>直接将相应写入到response body 和 返回null</li>
<li>返回一个<code>ModelAndView</code>对象由<code>DispatcherServlet</code>渲染。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">                    HttpServletResponse response, </div><div class="line">                    Object handler) <span class="keyword">throws</span> Exception;</div></pre></td></tr></table></figure>
<p>Spring提供了很多类型的处理器，下面是<code>SimpleControllerHandlerAdapter</code>如何处理Spring MVC的controller实例的(不要和@Controller搞混)。<br>注意，controller处理器返回ModelAndView对象并不是由起渲染的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">  HttpServletResponse response, Object handler) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    <span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个是<code>SimpleServletHandlerAdapter</code>它对一个普通的servlet适配。<br>servlet并不知道<code>ModelAndView</code>，完全自己处理请求，将返回写入到相应的body中。因此它的适配器就直接返回null。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">  HttpServletResponse response, Object handler) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    ((Servlet) handler).service(request, response);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在本例中，controller是由<code>@RequestMapping</code>修饰的POJO，因此处理器会使用<code>HandlerMethod</code>来封装它的方法。Spring使用<code>RequestMappingHandlerAdapter</code>来适配这种处理器类型。</p>
<h5 id="处理参数，返回处理器函数的值"><a href="#处理参数，返回处理器函数的值" class="headerlink" title="处理参数，返回处理器函数的值"></a>处理参数，返回处理器函数的值</h5><p>注意，一般来说controller并不会接收<code>HttpServletRequest</code>和<code>HttpServletResponse</code>作为参数，但是它可以接收和返回很多中其他类型，例如：领域对象，路径参数等。<br>同样，也不强求一个controller返回一个<code>ModelAndView</code>实例。可以选择返回一个视图名称，<code>ResponseEntity</code>，或者是一个可以被转换成JSON的POJO。<br><code>RequestMappingHandlerAdapter</code>可以保证从<code>HttpServletRequest</code>中解析方法需要的参数，同时创建<code>ModelAndView</code>对象返回。<br>下面这段代码就是<code>RequestMappingHandlerAdapter</code>中保证这件事情的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ServletInvocableHandlerMethod invocableMethod </div><div class="line">  = createInvocableHandlerMethod(handlerMethod);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</div><div class="line">    invocableMethod.setHandlerMethodArgumentResolvers(</div><div class="line">      <span class="keyword">this</span>.argumentResolvers);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</div><div class="line">    invocableMethod.setHandlerMethodReturnValueHandlers(</div><div class="line">      <span class="keyword">this</span>.returnValueHandlers);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>argumentResolvers</code>在<code>HandlerMethodArgumentResolver</code>实例中有不同实现。一共有30多种不同的参数解析器的实现。他们可以从请求参数将函数需要的参数解析出来。包括：url路径变量，请求体参数，请求头，cookies，session等。<br><code>returnValueHandlers</code>在<code>HandlerMethodArgumentResolver</code>实例中有不同实现。同样也有很多不同的返回值处理器来处理方法返回的结果，创建<code>ModelAndView</code>对象。<br>例如：当函数<code>hello()</code>返回一个string的时候，<code>ViewNameMethodReturnValueHandler</code>处理这个值。<code>login()</code>返回一个<code>ModelAndView</code>对象的时候，Sring使用<code>ModelAndViewMethodReturnValueHandler</code>处理这个值。</p>
<h5 id="渲染视图"><a href="#渲染视图" class="headerlink" title="渲染视图"></a>渲染视图</h5><p>现在Spring已经处理了HTTP请求，获取了<code>ModelAndView</code>实例，现在它需要在用户浏览器渲染HTML页面了。它依赖于由Model和选择的模版组成的<code>ModelAndView</code>对象。<br>同样的，Spring也可以渲染JSON ,XML或者其他HTTP协议接受的类型。这些将在接下来的REST相关了解更多。<br>现在回去看一下<code>DispatcherServlet</code>。<code>render()</code>首先使用<code>LocaleResolver</code>实例设置返回的Local。首先假设浏览器已经正确设置Accetp头。默认使用<code>AcceptHeaderLocaleResolver</code>来处理。<br>在渲染过程中，<code>ModelAndView</code>可以包含一个视图的名字或者是已经选择的视图，或者如果controller依赖于默认视图也可以没有。<br>既然<code>hello()</code>和<code>login()</code>方法制定了字符串名字作为视图名称，所以需要使用viewResolvers来查找视图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (ViewResolver viewResolver : <span class="keyword">this</span>.viewResolvers) &#123;</div><div class="line">    View view = viewResolver.resolveViewName(viewName, locale);</div><div class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ViewResolver的实现由很多，这里使用了由<code>thymeleaf-spring5</code>提供的<code>ThymeleafViewResolver</code>实现。解析器知道去哪里查找视图，并且提供相应的视图实例。<br>调用完<code>render()</code>之后，Spring就完成了将HTML页面渲染到用户浏览器的任务。</p>
<h5 id="REST-支持"><a href="#REST-支持" class="headerlink" title="REST 支持"></a>REST 支持</h5><p>除了MVC的场景，我们可以使用狂减创建rest web service。<br>一个简单的场景，可以使用由<code>@RequestBody</code>修饰的POJO作为参数。由<code>@ResponseBody</code>修饰方法，指定方法的返回结果直接写入到响应体中。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</div><div class="line"></div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="meta">@PostMapping</span>(<span class="string">"/message"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> MyOutputResource <span class="title">sendMessage</span><span class="params">(</span></span></div><div class="line">  @RequestBody MyInputResource inputResource) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyOutputResource(<span class="string">"Received: "</span></div><div class="line">      + inputResource.getRequestMessage());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>感谢SpringMVC的扩展性，这样做也是可以的。<br>框架使用<code>HttpMessageConverter</code>将内部DTO转换成REST的表示。例如：<code>MappingJackson2HttpMessageConverter</code>的可以使用Jackson库将转换model和JSON。<br>为了简化创建REST API，Srping 引入了<code>@RestController</code>注解。默认使用<code>@ResonseBody</code>这样就不需要在每个方法中使用了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulWebServiceController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/message"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> MyOutputResource <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyOutputResource(<span class="string">"Hello!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>在这篇文章中，详细描述了Spring MVC处理HTTP请求的各个步骤。了解到Spring 框架是如何将各个组件组合在一起提供处理HTTP协议的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2018/04/07/deep-in-spring-mvc/" data-id="cjg4tbp4g001cu7r8wm25lsb9" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2018/04/07/deep-in-spring-mvc/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringMVC/">SpringMVC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web/">Web</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java8-date-time-api" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/06/java8-date-time-api/" class="article-date">
  <time datetime="2018-04-05T16:39:10.000Z" itemprop="datePublished">2018-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/06/java8-date-time-api/">Java8 Date Time API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.studytrails.com/java/java8/java8_date_and_time/" target="_blank" rel="external">原文地址</a>  </p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Java8 带来了处理日期和时间需要的方式。几乎所有人都有使用Java Date 痛苦的经历。有很多人因此切换到了Joda Time，但是Java8现在有了更清晰，更可扩展的API。在我们学习API钱，先了解一下日期和时间的概念。Java日期遵循<a href="http://en.wikipedia.org/wiki/Gregorian_calendar" target="_blank" rel="external">公历</a>规则。表示时间和日期的类放在<code>java.time</code>包中。在这个包里比较重要的API有：  </p>
<ul>
<li><strong>java.time.Period</strong>: 表示日期时期时间中的日期。表示日期部分的，年、月、日。例如：1年，两个月，5天。</li>
<li><strong>java.time.Duration</strong>: 表示日期时间中的时间。 表示时间的，秒，纳秒。例如：5秒。</li>
<li><strong>java.time.Instant</strong>: 表示时间线的一瞬间。保存的是UNIX时间戳的秒数，同时有另一个字段保存纳秒。</li>
<li><strong>java.time.LocalDate</strong>: 保存日期时间中的日期，用年-月-日表示。不包含时区，是不可变类。</li>
<li><strong>java.time.LocalTime</strong>: 保存日期时间中的时间，不包含时区。</li>
<li><strong>java.time.LocalDateTime</strong>: 保存LocalDate和LocalTime，不包含时区。</li>
<li><strong>java.time.ZoneDateTime</strong>: 保存LocalDateTIme，使用<code>ZoneOffset</code>保存时区信息。可以访问ZoneRule来转换本地时间。</li>
<li><strong>java.time.ZoneOffset</strong>: 保存时区相对于UTC的位移，时区信息保存在ZoneId中。</li>
<li><strong>java.time.OffsetDateTime</strong>: 通过位移来表示本地时间。这个类不包含时区规则。    </li>
</ul>
<h5 id="创建本地日期"><a href="#创建本地日期" class="headerlink" title="创建本地日期"></a>创建本地日期</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instant now = Instant.now();</div><div class="line"><span class="comment">//2014-09-20T14:32:33.646Z</span></div></pre></td></tr></table></figure>
<p>这个语句创建了一个新的时间实例。这个实例没有时区信息，如果打印这个实例将会打印UTC时间。  </p>
<h5 id="打印Unix时间戳"><a href="#打印Unix时间戳" class="headerlink" title="打印Unix时间戳"></a>打印Unix时间戳</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.Println(now.getEpochSecond());</div><div class="line"><span class="comment">// prints 1411137153</span></div></pre></td></tr></table></figure>
<p>Unix时间戳是从1970-01-01T00:00:00Z开始的。</p>
<h5 id="Instant-加时间"><a href="#Instant-加时间" class="headerlink" title="Instant 加时间"></a>Instant 加时间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instant tomorrow = now.plus(<span class="number">1</span>, ChronoUnit.DAYS);</div><div class="line"><span class="comment">// prints 2014-09-20T14:32:33.646Z</span></div></pre></td></tr></table></figure>
<p>这个函数允许添加时间间隔。时间间隔可以是：NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS。</p>
<h5 id="Instant-减时间"><a href="#Instant-减时间" class="headerlink" title="Instant 减时间"></a>Instant 减时间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instant yesterday = now.minus(<span class="number">1</span>,ChronoUnit.HALF_DAYS);</div><div class="line"><span class="comment">// prints 2014-09-20T03:38:33.860Z</span></div></pre></td></tr></table></figure>
<p>这个minus函数允许从Instant中减时间，时间间隔同plus。</p>
<h5 id="对比两个Instant"><a href="#对比两个Instant" class="headerlink" title="对比两个Instant"></a>对比两个Instant</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(now.compareTo(tomorrow)); <span class="comment">// prints -1</span></div></pre></td></tr></table></figure>
<p>对比函数可以比较两个日期，如果参数在比较的Instant之后则返回-1，之前则返回1。</p>
<h5 id="检查Instant是否在另一个Instant之后"><a href="#检查Instant是否在另一个Instant之后" class="headerlink" title="检查Instant是否在另一个Instant之后"></a>检查Instant是否在另一个Instant之后</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(now.isAfter(yesterday));<span class="comment">// prints true</span></div></pre></td></tr></table></figure>
<h5 id="创建LocalDateTime"><a href="#创建LocalDateTime" class="headerlink" title="创建LocalDateTime"></a>创建LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDateTime localDateTime = LocalDateTime.now();</div><div class="line">System.out.println(localDateTime); <span class="comment">// prints 2014-09-28T13:01:40.556</span></div></pre></td></tr></table></figure>
<p>注意，这个得到的是本地时区的时间</p>
<h5 id="将LocalDateTime转换成其他时区时间"><a href="#将LocalDateTime转换成其他时区时间" class="headerlink" title="将LocalDateTime转换成其他时区时间"></a>将LocalDateTime转换成其他时区时间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(localDateTime.atZone(ZoneId.of(<span class="string">"America/New_York"</span>)));</div><div class="line"><span class="comment">// prints 2014-09-28T13:07:31.207-04:00[America/New_York]</span></div></pre></td></tr></table></figure>
<p>这个将会创建一个新的ZonedDateTime</p>
<h5 id="从DateTime中获取星期"><a href="#从DateTime中获取星期" class="headerlink" title="从DateTime中获取星期"></a>从DateTime中获取星期</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.out.println(DayOfWeek.from(localDateTime));</div><div class="line"><span class="comment">// prints SUNDAY.</span></div><div class="line"><span class="comment">// (yes, i am working on a sunday :-( ) ))</span></div></pre></td></tr></table></figure>
<h5 id="从DateTime中获取一年中第几天"><a href="#从DateTime中获取一年中第几天" class="headerlink" title="从DateTime中获取一年中第几天"></a>从DateTime中获取一年中第几天</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(localDateTime.get(ChronoField.DAY_OF_YEAR));</div><div class="line"><span class="comment">// prints 271</span></div></pre></td></tr></table></figure>
<p>其他的可以是MINUTE_OF_HOUR, MINUTE_OF_DAY, HOUR_OF_AMPM, HOUR_OF_DAY, AMPM_OF_DAY, DAY_OF_WEEK, DAY_OF_MONTH, DAY_OF_YEAR, MONTH_OF_YEAR, YEAR, OFFSET_SECONDS（UTC时间的位移）</p>
<h5 id="从LocalDateTime中获取LocalDate"><a href="#从LocalDateTime中获取LocalDate" class="headerlink" title="从LocalDateTime中获取LocalDate"></a>从LocalDateTime中获取LocalDate</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(localDateTime.toLocalDate());</div><div class="line"><span class="comment">// prints 2014-09-29</span></div></pre></td></tr></table></figure>
<h5 id="从LocalDateTIme中获取LocalTime"><a href="#从LocalDateTIme中获取LocalTime" class="headerlink" title="从LocalDateTIme中获取LocalTime"></a>从LocalDateTIme中获取LocalTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(localDateTime.toLocalTime());</div><div class="line"><span class="comment">// prints 22:26:30.146</span></div></pre></td></tr></table></figure>
<h5 id="通过年月日时分创建LocalDateTime"><a href="#通过年月日时分创建LocalDateTime" class="headerlink" title="通过年月日时分创建LocalDateTime"></a>通过年月日时分创建LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(LocalDateTime.of(<span class="number">2014</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>));</div><div class="line"><span class="comment">// prints 2014-10-01T10:00</span></div></pre></td></tr></table></figure>
<h5 id="通过解析字符串创建LocalDateTime"><a href="#通过解析字符串创建LocalDateTime" class="headerlink" title="通过解析字符串创建LocalDateTime"></a>通过解析字符串创建LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDateTime parsedLocalDateTime = LocalDateTime.parse(<span class="string">"2014-01-01T11:00"</span>);</div></pre></td></tr></table></figure>
<h5 id="创建另一个时区的LocalDateTime"><a href="#创建另一个时区的LocalDateTime" class="headerlink" title="创建另一个时区的LocalDateTime"></a>创建另一个时区的LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(LocalDateTime.now(ZoneId.of(<span class="string">"UTC"</span>)));</div><div class="line"><span class="comment">// prints 2014-09-29T17:07:26.653 (the local timezone in UTC)</span></div></pre></td></tr></table></figure>
<h5 id="通过Instant和时区创建LocalDateTime"><a href="#通过Instant和时区创建LocalDateTime" class="headerlink" title="通过Instant和时区创建LocalDateTime"></a>通过Instant和时区创建LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Instant now = Instant.now();</div><div class="line">System.out.println(LocalDateTime.ofInstant(now, ZoneId.of(<span class="string">"UTC"</span>)));</div><div class="line"><span class="comment">//2014-09-29T17:09:19.644</span></div></pre></td></tr></table></figure>
<h5 id="创建ZonedDateTime"><a href="#创建ZonedDateTime" class="headerlink" title="创建ZonedDateTime"></a>创建ZonedDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ZonedDateTime zonedDateTime = ZonedDateTime.now();</div><div class="line"><span class="comment">//2014-09-29T22:41:24.908+05:30[Asia/Calcutta]</span></div></pre></td></tr></table></figure>
<h5 id="获取两个不同时间在不同单位之差"><a href="#获取两个不同时间在不同单位之差" class="headerlink" title="获取两个不同时间在不同单位之差"></a>获取两个不同时间在不同单位之差</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(zonedDateTime.until(ZonedDateTime.parse(&quot;2014-09-29T22:41:00-10:00&quot;), ChronoUnit.HOURS));</div><div class="line">// prints the difference between the current zonedDateTime and the zonedatetime parsed from the above string</div></pre></td></tr></table></figure>
<h5 id="获取当前ZoneDateTime的位移"><a href="#获取当前ZoneDateTime的位移" class="headerlink" title="获取当前ZoneDateTime的位移"></a>获取当前ZoneDateTime的位移</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(zonedDateTime.getOffset());</div><div class="line"><span class="comment">// prints the offset e.g. +10:00</span></div></pre></td></tr></table></figure>
<h5 id="使用DateTimeFormatter解析或者格式化时间"><a href="#使用DateTimeFormatter解析或者格式化时间" class="headerlink" title="使用DateTimeFormatter解析或者格式化时间"></a>使用DateTimeFormatter解析或者格式化时间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(zonedDateTime.format(DateTimeFormatter.ofPattern(<span class="string">"'The' dd 'day of' MMM 'in year' YYYY 'and zone is' z"</span>)));</div><div class="line"><span class="comment">// prints The 29 day of Sep in year 2014 and zone is IST</span></div></pre></td></tr></table></figure>
<h5 id="将ZoneDateTime更改时区"><a href="#将ZoneDateTime更改时区" class="headerlink" title="将ZoneDateTime更改时区"></a>将ZoneDateTime更改时区</h5><p>有两种方式可以完成这个任务，第一种不更改Instant更改时区，第二种更改时区不更改LocalTime<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(zonedDateTime);</div><div class="line">System.out.println(zonedDateTime.toInstant());</div><div class="line">System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(<span class="string">"America/Chicago"</span>)));</div><div class="line">System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(<span class="string">"America/Chicago"</span>)));</div><div class="line"></div><div class="line"><span class="comment">// prints </span></div><div class="line"><span class="comment">//System.out.println(zonedDateTime);</span></div><div class="line"><span class="comment">//System.out.println(zonedDateTime.toInstant());</span></div><div class="line"><span class="comment">//System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of("America/Chicago")));</span></div><div class="line"><span class="comment">//System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of("America/Chicago")));</span></div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2018/04/06/java8-date-time-api/" data-id="cjg4tbp330005u7r8tuex6kef" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2018/04/06/java8-date-time-api/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java8/">Java8</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jackson-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/31/jackson-tutorial/" class="article-date">
  <time datetime="2018-03-30T16:39:10.000Z" itemprop="datePublished">2018-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/31/jackson-tutorial/">Jackson 简明教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://github.com/FasterXML/jackson-databind/" target="_blank" rel="external">原文地址</a>  </p>
<h4 id="一分钟教程：POJOs和JSON的互相转换"><a href="#一分钟教程：POJOs和JSON的互相转换" class="headerlink" title="一分钟教程：POJOs和JSON的互相转换"></a>一分钟教程：POJOs和JSON的互相转换</h4><p>&emsp;&emsp;最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Note: can use getters/setters as well; here we just use public fields directly:</div><div class="line">public class MyValue &#123;</div><div class="line">  public String name;</div><div class="line">  public int age;</div><div class="line">  // NOTE: if using getters/setters, can keep fields `protected` or `private`</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们需要一个<code>com.fasterxml.jackson.databind.ObjectMapper</code>的实例来做所有的数据绑定，<code>ObjectMapper</code>仅需要创建一次即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectMapper mapper = new ObjectMapper(); // create once, reuse</div></pre></td></tr></table></figure></p>
<p>采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用<code>ObjectMapper</code>的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MyValue value = mapper.readValue(new File(&quot;data.json&quot;), MyValue.class);</div><div class="line">// or:</div><div class="line">value = mapper.readValue(new URL(&quot;http://some.com/api/entry.json&quot;), MyValue.class);</div><div class="line">// or:</div><div class="line">value = mapper.readValue(&quot;&#123;\&quot;name\&quot;:\&quot;Bob\&quot;, \&quot;age\&quot;:13&#125;&quot;, MyValue.class);</div></pre></td></tr></table></figure></p>
<p>如果想要生成JSON，只需要反过来就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mapper.writeValue(new File(&quot;result.json&quot;), myResultObject);</div><div class="line">// or:</div><div class="line">byte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);</div><div class="line">// or:</div><div class="line">String jsonString = mapper.writeValueAsString(myResultObject);</div></pre></td></tr></table></figure></p>
<h4 id="三分钟教程：泛型集合和树模型"><a href="#三分钟教程：泛型集合和树模型" class="headerlink" title="三分钟教程：泛型集合和树模型"></a>三分钟教程：泛型集合和树模型</h4><p>除了处理Bean风格的POJO，Jackson同时可以处理JDK的<code>List</code>和<code>Map</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; scoreByName = mapper.readValue(jsonSource, Map.class);</div><div class="line">List&lt;String&gt; names = mapper.readValue(jsonSource, List.class);</div><div class="line"></div><div class="line">// and can obviously write out as well</div><div class="line">mapper.writeValue(new File(&quot;names.json&quot;), names);</div></pre></td></tr></table></figure></p>
<p>匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是<code>List</code>等类型，则不需要指定类型)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, ResultValue&gt; results = mapper.readValue(jsonSource,</div><div class="line">   new TypeReference&lt;Map&lt;String, ResultValue&gt;&gt;() &#123; &#125; );</div><div class="line">// why extra work? Java Type Erasure will prevent type detection otherwise &#125;)</div></pre></td></tr></table></figure></p>
<p>然而，处理<code>Map</code>,<code>List</code>和其他’简单’类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的<code>Tree Model</code>迟早有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// can be read as generic JsonNode, if it can be Object or Array; or,</div><div class="line">// if known to be Object, as ObjectNode, if array, ArrayNode etc:</div><div class="line">ObjectNode root = mapper.readTree(&quot;stuff.json&quot;);</div><div class="line">String name = root.get(&quot;name&quot;).asText();</div><div class="line">int age = root.get(&quot;age&quot;).asInt();</div><div class="line"></div><div class="line">// can modify as well: this adds child Object as property &apos;other&apos;, set property &apos;type&apos;</div><div class="line">root.with(&quot;other&quot;).put(&quot;type&quot;, &quot;student&quot;);</div><div class="line">String json = mapper.writeValueAsString(root);</div><div class="line"></div><div class="line">// with above, we end up with something like as &apos;json&apos; String:</div><div class="line">// &#123;</div><div class="line">//   &quot;name&quot; : &quot;Bob&quot;, &quot;age&quot; : 13,</div><div class="line">//   &quot;other&quot; : &#123;</div><div class="line">//      &quot;type&quot; : &quot;student&quot;</div><div class="line">//   &#125;</div><div class="line">// &#125;</div></pre></td></tr></table></figure></p>
<p>树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。</p>
<h4 id="五分钟教程：Streaming-parser-generator"><a href="#五分钟教程：Streaming-parser-generator" class="headerlink" title="五分钟教程：Streaming parser, generator"></a>五分钟教程：Streaming parser, generator</h4><p>有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">JsonFactory f = mapper.getFactory(); // may alternatively construct directly too</div><div class="line"></div><div class="line">// First: write simple JSON output</div><div class="line">File jsonFile = new File(&quot;test.json&quot;);</div><div class="line">JsonGenerator g = f.createGenerator(jsonFile);</div><div class="line">// write JSON: &#123; &quot;message&quot; : &quot;Hello world!&quot; &#125;</div><div class="line">g.writeStartObject();</div><div class="line">g.writeStringField(&quot;message&quot;, &quot;Hello world!&quot;);</div><div class="line">g.writeEndObject();</div><div class="line">g.close();</div><div class="line"></div><div class="line">// Second: read file back</div><div class="line">JsonParser p = f.createParser(jsonFile);</div><div class="line"></div><div class="line">JsonToken t = p.nextToken(); // Should be JsonToken.START_OBJECT</div><div class="line">t = p.nextToken(); // JsonToken.FIELD_NAME</div><div class="line">if ((t != JsonToken.FIELD_NAME) || !&quot;message&quot;.equals(p.getCurrentName())) &#123;</div><div class="line">   // handle error</div><div class="line">&#125;</div><div class="line">t = p.nextToken();</div><div class="line">if (t != JsonToken.VALUE_STRING) &#123;</div><div class="line">   // similarly</div><div class="line">&#125;</div><div class="line">String msg = p.getText();</div><div class="line">System.out.printf(&quot;My message to you is: %s!\n&quot;, msg);</div><div class="line">p.close(); &#125;</div></pre></td></tr></table></figure></p>
<h4 id="10分钟教程：配置"><a href="#10分钟教程：配置" class="headerlink" title="10分钟教程：配置"></a>10分钟教程：配置</h4><p>有两种入门的配置方法：feature 和 Annotation</p>
<h5 id="feature-配置"><a href="#feature-配置" class="headerlink" title="feature 配置"></a>feature 配置</h5><p>下面是一些最常用的配置<br>首先从高层的data-bind配置开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// SerializationFeature for changing how JSON is written</div><div class="line"></div><div class="line">// to enable standard indentation (&quot;pretty-printing&quot;):</div><div class="line">mapper.enable(SerializationFeature.INDENT_OUTPUT);</div><div class="line">// to allow serialization of &quot;empty&quot; POJOs (no properties to serialize)</div><div class="line">// (without this setting, an exception is thrown in those cases)</div><div class="line">mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</div><div class="line">// to write java.util.Date, Calendar as number (timestamp):</div><div class="line">mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</div><div class="line"></div><div class="line">// DeserializationFeature for changing how JSON is read as POJOs:</div><div class="line"></div><div class="line">// to prevent exception when encountering unknown property:</div><div class="line">mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</div><div class="line">// to allow coercion of JSON empty String (&quot;&quot;) to null Object value:</div><div class="line">mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</div></pre></td></tr></table></figure></p>
<p>下面是一些可以控制JSON底层解析，生成的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// JsonParser.Feature for configuring parsing settings:</div><div class="line"></div><div class="line">// to allow C/C++ style comments in JSON (non-standard, disabled by default)</div><div class="line">// (note: with Jackson 2.5, there is also `mapper.enable(feature)` / `mapper.disable(feature)`)</div><div class="line">mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);</div><div class="line">// to allow (non-standard) unquoted field names in JSON:</div><div class="line">mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);</div><div class="line">// to allow use of apostrophes (single quotes), non standard</div><div class="line">mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);</div><div class="line"></div><div class="line">// JsonGenerator.Feature for configuring low-level JSON generation:</div><div class="line"></div><div class="line">// to force escaping of non-ASCII characters:</div><div class="line">mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);</div></pre></td></tr></table></figure></p>
<h5 id="注解配置：修改属性名"><a href="#注解配置：修改属性名" class="headerlink" title="注解配置：修改属性名"></a>注解配置：修改属性名</h5><p>最简单的使用注解配置的方式是使用<code>@JsonProperty</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyBean &#123;</div><div class="line">   private String _name;</div><div class="line"></div><div class="line">   // without annotation, we&apos;d get &quot;theName&quot;, but we want &quot;name&quot;:</div><div class="line">   @JsonProperty(&quot;name&quot;)</div><div class="line">   public String getTheName() &#123; return _name; &#125;</div><div class="line"></div><div class="line">   // note: it is enough to add annotation on just getter OR setter;</div><div class="line">   // so we can omit it here</div><div class="line">   public void setTheName(String n) &#123; _name = n; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="注解配置：忽略属性"><a href="#注解配置：忽略属性" class="headerlink" title="注解配置：忽略属性"></a>注解配置：忽略属性</h5><p>有两个可以设置忽略属性的注解，一个是<code>@JsonIgnore</code> 修饰的是单个属性，一个是<code>@JsonIgnoreProperties</code> 修饰的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// means that if we see &quot;foo&quot; or &quot;bar&quot; in JSON, they will be quietly skipped</div><div class="line">// regardless of whether POJO has such properties</div><div class="line">@JsonIgnoreProperties(&#123; &quot;foo&quot;, &quot;bar&quot; &#125;)</div><div class="line">public class MyBean</div><div class="line">&#123;</div><div class="line">   // will not be written as JSON; nor assigned from JSON:</div><div class="line">   @JsonIgnore</div><div class="line">   public String internal;</div><div class="line"></div><div class="line">   // no annotation, public field is read/written normally</div><div class="line">   public String external;</div><div class="line"></div><div class="line">   @JsonIgnore</div><div class="line">   public void setCode(int c) &#123; _code = c; &#125;</div><div class="line"></div><div class="line">   // note: will also be ignored because setter has annotation!</div><div class="line">   public int getCode() &#123; return _code; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了<code>@JsonIgnore</code>，其他的也受影响。当然也可以使用分离的注解来解决问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class ReadButDontWriteProps &#123;</div><div class="line">   private String _name;</div><div class="line">   @JsonProperty public void setName(String n) &#123; _name = n; &#125;</div><div class="line">   @JsonIgnore public String getName() &#123; return _name; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>name</code>不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。</p>
<h5 id="注解配置：定制注解构造器"><a href="#注解配置：定制注解构造器" class="headerlink" title="注解配置：定制注解构造器"></a>注解配置：定制注解构造器</h5><p>和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CtorBean</div><div class="line">&#123;</div><div class="line">  public final String name;</div><div class="line">  public final int age;</div><div class="line"></div><div class="line">  @JsonCreator // constructor can be public, private, whatever</div><div class="line">  private CtorBean(@JsonProperty(&quot;name&quot;) String name,</div><div class="line">    @JsonProperty(&quot;age&quot;) int age)</div><div class="line">  &#123;</div><div class="line">      this.name = name;</div><div class="line">      this.age = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造函数在不可变对象中非常实用。<br>也可以直接定义一个工厂方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class FactoryBean</div><div class="line">&#123;</div><div class="line">    // fields etc omitted for brewity</div><div class="line"></div><div class="line">    @JsonCreator</div><div class="line">    public static FactoryBean create(@JsonProperty(&quot;name&quot;) String name) &#123;</div><div class="line">      // construct and return an instance</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="其他特性："><a href="#其他特性：" class="headerlink" title="其他特性："></a>其他特性：</h4><p>一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。<br>转换在兼容的类型中运行的很好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ResultType result = mapper.convertValue(sourceObject, ResultType.class);</div></pre></td></tr></table></figure></p>
<p>只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Convert from List&lt;Integer&gt; to int[]</div><div class="line">List&lt;Integer&gt; sourceList = ...;</div><div class="line">int[] ints = mapper.convertValue(sourceList, int[].class);</div><div class="line">// Convert a POJO into Map!</div><div class="line">Map&lt;String,Object&gt; propertyMap = mapper.convertValue(pojoValue, Map.class);</div><div class="line">// ... and back</div><div class="line">PojoType pojo = mapper.convertValue(propertyMap, PojoType.class);</div><div class="line">// decode Base64! (default byte[] representation is base64-encoded String)</div><div class="line">String base64 = &quot;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz&quot;;</div><div class="line">byte[] binary = mapper.convertValue(base64, byte[].class);</div></pre></td></tr></table></figure></p>
<p>基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2018/03/31/jackson-tutorial/" data-id="cjg4tbp4d0016u7r829h3o1lw" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2018/03/31/jackson-tutorial/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSON/">JSON</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jackson/">Jackson</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mybaits-configuration" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/28/mybaits-configuration/" class="article-date">
  <time datetime="2017-06-28T06:13:32.000Z" itemprop="datePublished">2017-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/28/mybaits-configuration/">MyBatis 配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.mybatis.org/mybatis-3/configuration.html" target="_blank" rel="external">原文链接</a></p>
<p>MyBatis的配置包含了设置和属性，他们对MyBatis的行为有很大的影响。MyBatis的配置文件层次结构如下：</p>
<ul>
<li>configuration<ul>
<li>properties</li>
<li>settings</li>
<li>typeAliases</li>
<li>typeHandlers</li>
<li>objectFactory</li>
<li>plugins</li>
<li>environments<ul>
<li>environment<ul>
<li>transactionManager</li>
<li>dataSource</li>
</ul>
</li>
</ul>
</li>
<li>databaseIdProvider</li>
<li>mappers</li>
</ul>
</li>
</ul>
<h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>可以通过一个典型的Java Properties 类实例配置可替换的外部属性，也可以通过子元素传递这些配置属性，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</div><div class="line">  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;</div><div class="line">  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;</div><div class="line">&lt;/properties&gt;</div></pre></td></tr></table></figure></p>
<p>然后这些配置属性就可以应用于配置文件中需要动态配置的其他属性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</div><div class="line">  &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</div><div class="line">  &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</div><div class="line">  &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</div><div class="line">  &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</div><div class="line">&lt;/dataSource&gt;</div></pre></td></tr></table></figure></p>
<p>在这个例子中的username和password将会被properties的配置属性替换。driver和url属性会被config.properties的配置替换。这个为配置提供了很多的选项。<br>Properties同样可以直传入SqlSessionFactoryBuild.build() 方法中，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);</div><div class="line"></div><div class="line">// ... or ...</div><div class="line"></div><div class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);</div></pre></td></tr></table></figure></p>
<p>如果同一个属性同时配置到不同的位置，MyBatis按照如下的顺序加载它们：    </p>
<ol>
<li>在Properties内的子元素首先被加载。     </li>
<li>其次从resource classpath和url中加载属性并覆盖已存在的属性。    </li>
<li>作为方法参数的属性最后被加载，并且覆盖前面两次相同的属性。</li>
</ol>
<p>因此，优先级最高的是直接作为参数传入方法，其次是从resource classpath或者url加载的配置文件，最后是Properties中的子元素定义的属性。<br>MyBatis 3.4.2 之后可以如下使用默认占位符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</div><div class="line">  &lt;!-- ... --&gt;</div><div class="line">  &lt;property name=&quot;username&quot; value=&quot;$&#123;username:ut_user&#125;&quot;/&gt; &lt;!-- If &apos;username&apos; property not present, username become &apos;ut_user&apos; --&gt;</div><div class="line">&lt;/dataSource&gt;</div></pre></td></tr></table></figure></p>
<p>这个功能默认是无效的，如果要开启这个功能，需要在配置属性中如下开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</div><div class="line">  &lt;!-- ... --&gt;</div><div class="line">  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;</div><div class="line">&lt;/properties&gt;</div></pre></td></tr></table></figure></p>
<p>注意：如果已经使用了“：”作为属性的键例如：<code>db:username</code>，或者是在sql的定义中使用了OGNL的三元符，例如：<code>${tableName != null ? tableName : &#39;global_constants&#39;}</code>那么就需要修改默认的分隔符，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</div><div class="line">  &lt;!-- ... --&gt;</div><div class="line">  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- Change default value of separator --&gt;</div><div class="line">&lt;/properties&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</div><div class="line">  &lt;!-- ... --&gt;</div><div class="line">  &lt;property name=&quot;username&quot; value=&quot;$&#123;db:username?:ut_user&#125;&quot;/&gt;</div><div class="line">&lt;/dataSource&gt;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2017/06/28/mybaits-configuration/" data-id="cjg4tbp56001uu7r8gy0gqyeq" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2017/06/28/mybaits-configuration/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mybatis/">Mybatis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Translate/">Translate</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cup-load-high" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/25/cup-load-high/" class="article-date">
  <time datetime="2017-03-25T03:20:26.000Z" itemprop="datePublished">2017-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/25/cup-load-high/">Linux 如何查找Java 程序CPU负载过高</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&emsp;&emsp;准备程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        new Thread(new Runnable()&#123;</div><div class="line">            public void run()&#123;</div><div class="line">                while(true)&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其中一个线程回导致一直占用CPU，编译运行。通过<code>top</code> 获取CPU占用信息<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/top.png" alt="top cpu"><br>可以看到占用最高的 pid是 25955<br>通过<code>top -p 25955 -H</code> 获取进程内部线程的CPU使用率。<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/tophp.png" alt="topph"><br>可以发现占用最高的线程ID是 <code>25965</code> 将其转换为16进制<code>python -c &#39;print hex(25965)&#39;</code> 得到的值是<code>0x656d</code><br>使用 <code>jstack -l 25955 &gt; jstack.log</code> 得到Java进程的Thread dump，通过 <code>grep -i 0x656d -A 30 jstack.log</code> 获取Java Thread id为0x656d的线程的thread dump。<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/jstack.png" alt="jstack"><br>然后就可以定位相应代码查找代码占用CPU过高问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2017/03/25/cup-load-high/" data-id="cjg4tbp2n0000u7r8nc7c4f37" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2017/03/25/cup-load-high/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CPU/">CPU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Git分支" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/24/Git分支/" class="article-date">
  <time datetime="2017-03-24T03:32:02.000Z" itemprop="datePublished">2017-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/24/Git分支/">Git - 分支管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="分支概要-Nutshell"><a href="#分支概要-Nutshell" class="headerlink" title="分支概要(Nutshell)"></a>分支概要(Nutshell)</h3><p>&emsp;&emsp; 几乎每个版本管理系统（<em>VCS</em>）都对分支有一些支持。分支就是从开发的主线分开，在其他地方继续开发，这样不至于和主线的开发产生混乱。在大多的VCS工具里，分支管理是一个复杂的流程，经常需要你为源代码目录创建一份拷贝，对于一些大型项目这会花费大量时间。</p>
<p>&emsp;&emsp; 真正理解分支首先需要明白<strong>Git</strong>是如何存储数据的：<strong>Git</strong>不会储存不同的或变化的点，而是保存一个快照（snapshot）。</p>
<p>&emsp;&emsp; 当你提交一个commit，<strong>Git</strong>会存储一个commit对象，这个对象包含：</p>
<ul>
<li>指向当前内容的快照的引用（pointer）</li>
<li>作者的姓名、邮件地址和提交的信息</li>
<li>指向上一次提交的commit的引用 （如果上一次操作是多个分支的merge操作，那么会储存多个指向不同的commit的引用；如果当前提交是首次commit，因为没有上一次commit，所以不会存储任何指向上一次commit的引用；正常的commit，会储存一个指向上次commit的引用）</li>
</ul>
<p>&emsp;&emsp; 视觉化地理解这个流程就是：假设你有一个包含三个文件的目录，添加（add操作）这三个文件后commit。添加文件时会为每个文件生成一个校验码(SHA-1 hash)，在<strong>Git</strong>的仓库(<em>repo</em>)存储文件的版本，同时添加校验码到添加的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README test.rb LICENSE</div><div class="line">$ git commit -m &apos;The initial commit of my project&apos;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 当你执行<code>git commit</code>后提交这个commit，<strong>Git</strong>会校验和每个子目录（在这个case里，只有项目的根目录），同时在<strong>Git repo</strong>里存储这些树对象。Git之后会创建一个commit对象，这个对象包含元数据和一个指向根项目树的引用 – 可以再次创建项目快照。</p>
<p>&emsp;&emsp; 你的<strong>Git repo</strong>现在包含5个对象：</p>
<ul>
<li>对应3个文件内容的3个二进制对象</li>
<li>一个树对象，呈现目录的内容和详细说明文件名和二进制对象的对应关系</li>
<li>一个commit对象，包含指向根树的引用，和commit对象的所有元数据</li>
</ul>
<p>&emsp;&emsp; 如下图所示：</p>
<p><img src="https://git-scm.com/book/en/v2/images/commit-and-tree.png" alt="Interceptors"></p>
<p>&emsp;&emsp; 如果文件做了变动，再次提交，这次提交会存储一个指向上一次提交的引用</p>
<p><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt="Interceptors"></p>
<p>&emsp;&emsp; <strong>Git</strong>的分支就是一个的简单的、轻量的、可移动的、指向这些个commit的引用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mashuai.github.io/2017/03/24/Git分支/" data-id="cjg4tbp4m001eu7r8rcu8531o" class="article-share-link">Share</a>
      
        <a href="https://mashuai.github.io/2017/03/24/Git分支/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git分支/">Git分支</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/APM/">APM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ansible/">Ansible</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Architecture/">Architecture</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU/">CPU</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git分支/">Git分支</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP-2/">HTTP/2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSON/">JSON</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jackson/">Jackson</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java8/">Java8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Middleware/">Middleware</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/">Mybatis</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKHttp/">OKHttp</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Performance/">Performance</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/">SpringMVC</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Translate/">Translate</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vagrant/">Vagrant</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/APM/" style="font-size: 10px;">APM</a> <a href="/tags/Ansible/" style="font-size: 11.67px;">Ansible</a> <a href="/tags/Architecture/" style="font-size: 10px;">Architecture</a> <a href="/tags/CPU/" style="font-size: 10px;">CPU</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Git分支/" style="font-size: 10px;">Git分支</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/HTTP/" style="font-size: 16.67px;">HTTP</a> <a href="/tags/HTTP-2/" style="font-size: 10px;">HTTP/2</a> <a href="/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/tags/Jackson/" style="font-size: 10px;">Jackson</a> <a href="/tags/Java/" style="font-size: 18.33px;">Java</a> <a href="/tags/Java8/" style="font-size: 10px;">Java8</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Middleware/" style="font-size: 10px;">Middleware</a> <a href="/tags/Mybatis/" style="font-size: 11.67px;">Mybatis</a> <a href="/tags/OKHttp/" style="font-size: 15px;">OKHttp</a> <a href="/tags/Performance/" style="font-size: 10px;">Performance</a> <a href="/tags/Spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/SpringMVC/" style="font-size: 13.33px;">SpringMVC</a> <a href="/tags/Translate/" style="font-size: 20px;">Translate</a> <a href="/tags/Vagrant/" style="font-size: 11.67px;">Vagrant</a> <a href="/tags/Web/" style="font-size: 10px;">Web</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/10/spring-mvc-controller/">SpringMVC 教程 - Controller</a>
          </li>
        
          <li>
            <a href="/2018/04/09/spring-mvc-dispatcher-servlet/">SpringMVC 教程 - DispatcherServlet</a>
          </li>
        
          <li>
            <a href="/2018/04/09/spring-mvc-filter/">SpringMVC 教程 - Filter</a>
          </li>
        
          <li>
            <a href="/2018/04/07/8-key-application-metrics/">8个关键的应用性能指标</a>
          </li>
        
          <li>
            <a href="/2018/04/07/deep-in-spring-mvc/">深入理解Spring MVC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 mashuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
<script src="https://s4.cnzz.com/z_stat.php?id=1261529414&web_id=1261529414" language="JavaScript"></script>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/projects" class="mobile-nav-link">Projects</a>
  
    <a href="/velocity" class="mobile-nav-link">Velocity</a>
  
</nav>
    
<script>
  var disqus_shortname = 'jabfor';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

    <!-- ad start -->
<!--    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 测试广告 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2889123346235419"
     data-ad-slot="8165482683"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
 -->
    <!-- ad end -->
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48348924-2', 'auto');
  ga('send', 'pageview');

</script>

  </div>

</body>
</html>
