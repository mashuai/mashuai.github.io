<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>代码拾遗</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mashuai.github.io/"/>
  <updated>2018-04-18T08:02:50.503Z</updated>
  <id>https://mashuai.github.io/</id>
  
  <author>
    <name>mashuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringMVC 教程 - Controller</title>
    <link href="https://mashuai.github.io/2018/04/10/spring-mvc-controller/"/>
    <id>https://mashuai.github.io/2018/04/10/spring-mvc-controller/</id>
    <published>2018-04-09T16:39:10.000Z</published>
    <updated>2018-04-18T08:02:50.503Z</updated>
    
    <content type="html"><![CDATA[<h5 id="声明Controller"><a href="#声明Controller" class="headerlink" title="声明Controller"></a>声明Controller</h5><p>Controller也是一个标准的Spring bean，可以在Servlet的<code>WebApplicationContext</code>中定义。也可以使用<code>@Controller</code>注解，Spring会扫描注解自动注册为Spring的bean。<br>开启自动注册<code>@Controller</code>注解的bean可以使用如下Java Config的配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>(<span class="string">"org.example.web"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用xml配置，如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">        http://www.springframework.org/schema/beans</div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example.web"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- ... --&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h5><p><code>@RequestMapping</code>可以将请求映射到具体的Controller方法上。通过找到匹配的url，http 方法，请求参数，header，媒体类型来映射请求。这个注解既可以用在类级别，也可以用在方法级别上。<br>为了方便<code>@RequestMapping</code>根据HTTP方法不同提供了如下快捷注解：</p>
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@DeleteMapping</li>
<li>@PutMapping</li>
<li>@PatchMapping</li>
</ul>
<p>示例如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/persons"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PostMapping</span></div><div class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(@RequestBody Person person)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="URI-模式"><a href="#URI-模式" class="headerlink" title="URI 模式"></a>URI 模式</h5><p>请求映射支持glob模式和通配符</p>
<ul>
<li><code>?</code> 匹配一个字符</li>
<li><code>*</code> 匹配0个或多个字符</li>
<li><code>**</code> 匹配0个或多个路径<br>可以通过<code>@PathVariable</code> 访问在URI中定义的变量：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">findPet</span><span class="params">(@PathVariable Long ownerId, @PathVariable Long petId)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line">``` </div><div class="line">URI的变量可以在类和方法中定义：</div><div class="line">```Java</div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/owners/&#123;ownerId&#125;"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/pets/&#123;petId&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">findPet</span><span class="params">(@PathVariable Long ownerId, @PathVariable Long petId)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>URI变量会自动类型转换，如果失败会抛出<code>TypeMismatchException</code>的异常。默认支持<code>int</code>,<code>long</code>,<code>Date</code>等类型，也可以通过DataBinder和 Type Conversion来注册其他需要支持的类型。<br>URI变量名也可以明确的支持，例如<code>@PathVariable(&quot;customId&quot;)</code>，不过如果在编译的时候带着调试信息，或者对于Java8 使用<code>-parameters</code> 编译，则可以不需要明确的命名。<br>语法<code>{varName:regex}</code>表示变量根据正则表达是来匹配，例如”/spring-web-3.0.5 .jar”可以使用以下表达式匹配<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(@PathVariable String version, @PathVariable String ext)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>URI同样可以有内嵌的<code>${}</code>的占位符，在应用启动的时候由<code>PropertyPlaceHolderConfigurer</code>从本地，系统，环境变量或者其他配置中解析。<br>Spring MVC使用的是Spring core 中的<code>AntPathMatcher</code>来匹配路径。</p>
<h5 id="模式对比"><a href="#模式对比" class="headerlink" title="模式对比"></a>模式对比</h5><p>当有很多模式匹配URI的时候，必须通过对比来找到最合适的匹配。这个是通过<code>AntPathMatcher.getPatternComparator(String path)</code>来实现。<br>可以根据URI中的变量个数，通配符个数来给URL打分，如果一个URI的变量少，通配符多，那么他得到的分数就会低。当匹配的模式分数相同是，选择匹配模式长的那个，如果分数和长度都相同，选择变量比通配符少的那个。<br><code>/**</code>是不参与评分的，而且总会是最后一个选择。同样<code>/plublic/**</code>也是当匹配不到其他没有两个通配符的模式的时候才会被选择。<br>了解更加详细的信息可以查看<code>AntPathMatcher</code>中的<code>AntPatternComparator</code>。同时也可个继承<code>PathMatcher</code>来定制URI匹配。</p>
<h5 id="后缀匹配"><a href="#后缀匹配" class="headerlink" title="后缀匹配"></a>后缀匹配</h5><p>Spring MVC 默认启动<code>.*</code>后缀匹配模式，这样映射到<code>/person</code>的controller 同样可以映射到<code>/person.*</code>。扩展名可以用来代替header中的<code>Accept</code>表示请求返回的类型。例如<code>person.pdf</code>,<code>person.xml</code>等。<br>因为过去浏览器的<code>Accept</code>头很难解析，所以这么是有意要的，但是现在浏览器的<code>Accept</code>更加清晰明确了，所以更好的选择是用<code>Accept</code>。而且过去一段时间内，使用后缀名匹配的时候会有各种各样的问题，当使用URI变量，路径参数，URI编码时后缀模式会导致歧义。<br>可以使用以下方法关闭后缀模式：</p>
<ul>
<li><code>PathMatchConfigurer</code>的<code>useSuffixPatternMatching(false)</code></li>
<li><code>ContentNeogiationConfigurer</code> 的<code>favorPathExtension(false)</code><h5 id="后缀匹配和RFD"><a href="#后缀匹配和RFD" class="headerlink" title="后缀匹配和RFD"></a>后缀匹配和RFD</h5>反射型文件下载(RFD)攻击和XSS攻击很相似。XSS依赖于请求的输入，例如查询参数，URI变量等，而RFD是用户点击URL浏览器会下载恶意文件，用户点击后会攻击主机。<br>由于Spring MVC的 <code>@ResponseBody</code>和<code>ResponseEntity</code>会根据URI后缀来渲染不同类型的响应内容，所以可能受到RFD攻击。关闭后缀匹配可以降低攻击的风险，但是不能完全防止RFD攻击。<br>为了防止RFD攻击，可以在渲染响应内容的时候添加<code>Content-Disposition:inline;filename=f.txt</code>确保一个安全的下载文件。<br>默认情况下大多数扩展名都有白名单，可以通过继承<code>HttpMessageConverter</code>对内容协商注册扩展，可以避免在响应中添加<code>Content-Disposition</code>。<h5 id="可消费媒体类型"><a href="#可消费媒体类型" class="headerlink" title="可消费媒体类型"></a>可消费媒体类型</h5>通过请求的<code>Content-Type</code>可以缩小请求的匹配范围，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostMapping</span>(path = <span class="string">"/pets"</span>, consumes = <span class="string">"application/json"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPet</span><span class="params">(@RequestBody Pet pet)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>consumes也支持表达式求反操作，例如<code>!text/plain</code>指的就除了<code>text/plain</code>都可以。<br>可以定义一个类级别的consumes，其方法共享这个consumes，和其他的<code>@ReqeustMapping</code>的属性不同，方法的consumes会覆盖类的定义。</p>
<h5 id="可产生的媒体类型"><a href="#可产生的媒体类型" class="headerlink" title="可产生的媒体类型"></a>可产生的媒体类型</h5><p>可以通过<code>Accept</code>头来缩小请求的匹配范围，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets/&#123;petId&#125;"</span>, produces = <span class="string">"application/json;charset=UTF-8"</span>)</div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>媒体类型可以指定一个字符集。对表达式取反也是支持的，例如：<code>!text/plain</code>指的就是除了<code>text/plain</code>都可以。<br>和consumes一样，也可以指定一个类级别的produces，其方法属性也会覆盖类的属性。</p>
<h5 id="参数和HTTP-header"><a href="#参数和HTTP-header" class="headerlink" title="参数和HTTP header"></a>参数和HTTP header</h5><p>可以通过参数来缩小请求匹配的范围。可以设置是否有参数(“myParam”),反过来是否没有(“!myParam”)或者指定一个值（”myParam=myValue”)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets/&#123;petId&#125;"</span>, params = <span class="string">"myParam=myValue"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样的情况也适合HTTP header<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/pets"</span>, headers = <span class="string">"myHeader=myValue"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(@PathVariable String petId)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;声明Controller&quot;&gt;&lt;a href=&quot;#声明Controller&quot; class=&quot;headerlink&quot; title=&quot;声明Controller&quot;&gt;&lt;/a&gt;声明Controller&lt;/h5&gt;&lt;p&gt;Controller也是一个标准的Spring bean，可
    
    </summary>
    
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="SpringMVC" scheme="https://mashuai.github.io/tags/SpringMVC/"/>
    
      <category term="Spring" scheme="https://mashuai.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 教程 - Filter</title>
    <link href="https://mashuai.github.io/2018/04/09/spring-mvc-filter/"/>
    <id>https://mashuai.github.io/2018/04/09/spring-mvc-filter/</id>
    <published>2018-04-08T16:39:10.000Z</published>
    <updated>2018-04-17T04:21:09.586Z</updated>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p><code>spring-web</code>模块提供了许多非常实用的Filter</p>
<h5 id="HTTP-PUT-FORM"><a href="#HTTP-PUT-FORM" class="headerlink" title="HTTP PUT FORM"></a>HTTP PUT FORM</h5><p>浏览器只能通过GET或者POST提交FORM数据，但是非浏览器的客户端可以使用PUT或者PATCH。Servlet API仅为POST方法提供了<code>ServletRequest.getParameter*()</code>方法获取FORM信息。<br><code>spring-web</code>模块提供了<code>HttpPutFormContentFilter</code>检查PUT或者PATCH方法的<code>content-type</code>是否是<code>application/x-www-form-urlencoded</code>,如果是，则从请求体重读取属性并封装到<code>ServletRequest</code>中，以便日后通过<code>ServletRequest.getParameter*()</code>获取FORM数据。</p>
<h5 id="重定向头"><a href="#重定向头" class="headerlink" title="重定向头"></a>重定向头</h5><p>由于请求会经过像负载均衡器这样的代理，那么host，port，scheme在创建一些资源文件的链接的时候返回给客户端可能是有所不同的。<br>RFC 7239 为代理定义了<code>Forwarded</code> 的HTTP头来提供原始请求的信息。同样也有一些其他非标准的HTTP头，例如：<code>X-Forwarded-Host</code>,<code>X-Forwarded-Port</code>,<code>X-Forwarded-Proto</code>。<br><code>ForwardedHeaderFilter</code>会从<code>Forwarded</code>,<code>X-Forwarded-Host</code>,<code>X-Forwarded-Port</code>或者<code>X-Forwarded-Proto</code>中获取跳转信息。他分装了请求以覆盖host，port，scheme，同样为日后的处理隐藏跳转信息。<br>注意，根据RFC 7239第八节的解释，使用重定向头的时候会有安全问题。在应用层是无法判断一个挑战是否是可信的。所以要正确配置网络上游代理，以便过滤掉不合法的跳转。<br>如果应用没有使用代理，那么就无需使用<code>ForwardedHeaderFilter</code>过滤器。</p>
<h5 id="Shallow-ETag"><a href="#Shallow-ETag" class="headerlink" title="Shallow ETag"></a>Shallow ETag</h5><p><code>ShallowEtagHeaderFilter</code>为ETG提供了过滤器，关于ETAG将在视图技术中详细解释。</p>
<h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p>通过controller的注解Spring MVC对CORS提供了详细的支持。在和Spring Sercurity一同使用的时候<code>CorsFilter</code>必须排在Spring Sercurity的过滤器之前。</p>
<h5 id="关于CORS"><a href="#关于CORS" class="headerlink" title="关于CORS"></a>关于CORS</h5><p>由于安全原因，浏览器禁止AJAX跳出当前域去访问资源。例如你的银行帐号在一个tab页打卡了，另一个evil.com在其他tab打开。evil.com的脚本不能使用你的银行账号信息去访问银行的API。<br>Cross-Origin Resource Sharing (CORS) 是由众多浏览器实现的W3C的规范。他规定了允许哪些请求可以跨域，而不是通过弱安全的和功能受限的IFRAME和JSONP。<br><code>HandlerMapping</code>对CORS提供了内置支持。成功将请求映射到处理器后，<code>HandlerMapping</code>对当前请求检查CORS配置，预检请求直接处理，简单和实际请求则检查CORS请求，验证，设置返回header。<br>为了开启跨域请求（例如<code>Origin</code>头和请求的host不一致），需要对CORS进行明确的配置。如果没有找到CORS的配置，那么直接拒绝预检请求，简单请求和实际请求不会添加响应头，因此浏览器不会获取到信息。<br>每一个<code>HandlerMapping</code>都可以根据URL不同配置单独的 <code>CorsConfiguration</code>。一般来说应用会通过Java Config或者Xml 命名空间来配置单一，全局的CORS。<br><code>HandlerMapping</code>级别的全局CORS配置可以和handler级别的CORS合并。例如有注解的controller可以使用类或者方法级别的注解<code>@CrossOrigin</code>配置跨域。<br><code>@CrossOrigin</code>注解可以在controller层启动对请求的跨域检查，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/account"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@CrossOrigin</span></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">retrieve</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认情况下<code>@CrossOrigin</code>的作用如下：</p>
<ul>
<li>允许所有的域</li>
<li>允许所有header</li>
<li>允许controller映射的方法</li>
<li><code>allowedCredentials</code> 默认关闭</li>
<li><code>max-age</code>默认30分钟<br><code>@CrossOrigin</code>同样支持类级别：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CrossOrigin</span>(origins = <span class="string">"http://domain2.com"</span>, maxAge = <span class="number">3600</span>)</div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/account"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">retrieve</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>@CrossOrigin</code>同时可以在类和方法中使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CrossOrigin</span>(maxAge = <span class="number">3600</span>)</div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/account"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@CrossOrigin</span>(<span class="string">"http://domain2.com"</span>)</div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">retrieve</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过定义全局的CORS配置，来配合使用。全局的CORS配置可以通过Java Config或者XML的XNM命名空间来配置。<br>默认情况下全局的CORS配置：</p>
<ul>
<li>允许所有的域</li>
<li>允许所有的header</li>
<li>允许GET,HEAD，POST方法</li>
<li><code>allowedCredentials</code> 默认关闭</li>
<li><code>max-age</code>默认30分钟<br>使用Java配置CORS<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableWebMvc</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</div><div class="line"></div><div class="line">        registry.addMapping(<span class="string">"/api/**"</span>)</div><div class="line">            .allowedOrigins(<span class="string">"http://domain2.com"</span>)</div><div class="line">            .allowedMethods(<span class="string">"PUT"</span>, <span class="string">"DELETE"</span>)</div><div class="line">            .allowedHeaders(<span class="string">"header1"</span>, <span class="string">"header2"</span>, <span class="string">"header3"</span>)</div><div class="line">            .exposedHeaders(<span class="string">"header1"</span>, <span class="string">"header2"</span>)</div><div class="line">            .allowCredentials(<span class="keyword">true</span>).maxAge(<span class="number">3600</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Add more mappings...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用XML配置CORS<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mvc:cors</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/api/**"</span></span></div><div class="line">        <span class="attr">allowed-origins</span>=<span class="string">"http://domain1.com, http://domain2.com"</span></div><div class="line">        <span class="attr">allowed-methods</span>=<span class="string">"GET, PUT"</span></div><div class="line">        <span class="attr">allowed-headers</span>=<span class="string">"header1, header2, header3"</span></div><div class="line">        <span class="attr">exposed-headers</span>=<span class="string">"header1, header2"</span> <span class="attr">allow-credentials</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">max-age</span>=<span class="string">"123"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/resources/**"</span></span></div><div class="line">        <span class="attr">allowed-origins</span>=<span class="string">"http://domain1.com"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">mvc:cors</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>另外，也可以通过<code>CorsFilter</code>配置CORS。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</div><div class="line"></div><div class="line"><span class="comment">// Possibly...</span></div><div class="line"><span class="comment">// config.applyPermitDefaultValues()</span></div><div class="line"></div><div class="line">config.setAllowCredentials(<span class="keyword">true</span>);</div><div class="line">config.addAllowedOrigin(<span class="string">"http://domain1.com"</span>);</div><div class="line">config.addAllowedHeader(<span class="string">""</span>);</div><div class="line">config.addAllowedMethod(<span class="string">""</span>);</div><div class="line"></div><div class="line">UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</div><div class="line">source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</div><div class="line"></div><div class="line">CorsFilter filter = <span class="keyword">new</span> CorsFilter(source);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;p&gt;&lt;code&gt;spring-web&lt;/code&gt;模块提供了许多非常实用的Filter&lt;/p&gt;
&lt;h5 id=&quot;HTTP-PUT-FORM&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="SpringMVC" scheme="https://mashuai.github.io/tags/SpringMVC/"/>
    
      <category term="Spring" scheme="https://mashuai.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 教程 - DispatcherServlet</title>
    <link href="https://mashuai.github.io/2018/04/09/spring-mvc-dispatcher-servlet/"/>
    <id>https://mashuai.github.io/2018/04/09/spring-mvc-dispatcher-servlet/</id>
    <published>2018-04-08T16:39:10.000Z</published>
    <updated>2018-04-17T01:47:30.628Z</updated>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>同许多其他的web框架一样，SpringMVC使用了前端控制器的设计模式，即一个以<code>DispatcherServlet</code>为核心的<code>Servlet</code>为处理请求提供了一个共享的算法，而实际的工作是由可配置的委托组件执行的。这个模式即灵活又支持多样的工作流。<br>同其他的<code>Servlet</code>,依照Servlet 规范<code>DispatcherServlet</code>需要在web.xml或者Java配置中声明并映射URL。接着<code>DispatcherServlet</code>使用Spring的配置来查找委托组件，用来映射URL，解析视图，异常处理等。<br>下面这个示例是使用Java配置来注册并初始化<code>DispatcherServlet</code>，这个类由Servlet容器自动发现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletCxt)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Load Spring web application configuration</span></div><div class="line">        AnnotationConfigWebApplicationContext ac = <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</div><div class="line">        ac.register(AppConfig.class);</div><div class="line">        ac.refresh();</div><div class="line"></div><div class="line">        <span class="comment">// Create and register the DispatcherServlet</span></div><div class="line">        DispatcherServlet servlet = <span class="keyword">new</span> DispatcherServlet(ac);</div><div class="line">        ServletRegistration.Dynamic registration = servletCxt.addServlet(<span class="string">"app"</span>, servlet);</div><div class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</div><div class="line">        registration.addMapping(<span class="string">"/app/*"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面这个示例是使用<code>web.xml</code>来注册并初始化的<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h5><p><code>DispatcherServlet</code>需要一个扩展了的<code>ApplicationContext</code>的<code>WebApplicationContext</code>来配置自己的信息。<code>WebApplicationContext</code>包含了<code>Servlet</code>的<code>ServletContext</code>的引用，可以使用<code>RequestContextUtils</code>中的静态方法从<code>WebApplicationContext</code>中查找<code>ServletContext</code>。<br>对于大多数应用来说一个<code>WebApplicationContext</code>就足够了。当然<code>WebApplicatioContext</code>也可以是有层次结构的，例如由多个Servlet共享的一个根<code>WebApplicationContext</code>，每个Servlet又有自己的子<code>WebApplicationContext</code>。<br>根<code>WebApplicationContext</code>一般包括需要在多个Servlet中共享的基础bean，例如数据仓库，业务逻辑等。在Servlet规范中，这些bean可以被有效的继承和改写，子<code>WebApplicationContext</code>仅包含在其属于的Servlet中。<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/mvc-context-hierarchy.png" alt="spring mvc context"><br>下面这个例子就是<code>WebApplicationContext</code>的层级配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; RootConfig.class &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; App1Config.class &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/app1/*"</span> &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样的，在web.xml中的配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app1-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app1/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="特殊的bean类型"><a href="#特殊的bean类型" class="headerlink" title="特殊的bean类型"></a>特殊的bean类型</h5><p><code>DispatcherServlet</code>委托专用的bean来处理请求，渲染响应。专用的bean指的是Spring管理的，实现WebFlux框架约定的实例。这些bean一般都是内建的约定，但是可以定制他们的属性，扩展或者代替这些bean。</p>
<table>
<thead>
<tr>
<th style="text-align:left">bean 类型</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HandlerMapping</td>
<td style="text-align:left">处理器映射，具体由其子类实现。两个重要的子类，<code>RequestMappingHandlerMapping</code>,<code>SimpleUrlHandlerMapping</code></td>
</tr>
<tr>
<td style="text-align:left">HandlerAdapter</td>
<td style="text-align:left">辅助<code>DispatcherServlet</code>执行特定的处理器。</td>
</tr>
<tr>
<td style="text-align:left">HandlerExceptionResolver</td>
<td style="text-align:left">将异常重定向到其他处理器或者是显示HTML的错误界面。</td>
</tr>
<tr>
<td style="text-align:left">ViewResolver</td>
<td style="text-align:left">通过处理器返回的视图字符串查找具体的视图并渲染。 </td>
</tr>
<tr>
<td style="text-align:left">LocaleResolver, LocaleContextResolver</td>
<td style="text-align:left">支持国际化页面，使用例如时区等来解析本地化问题。 </td>
</tr>
<tr>
<td style="text-align:left">ThemeResolver</td>
<td style="text-align:left">解析应用可用的主题，例如提供个性化框架 </td>
</tr>
<tr>
<td style="text-align:left">MultipartResolver</td>
<td style="text-align:left">处理上传文件 </td>
</tr>
<tr>
<td style="text-align:left">FlashMapManager</td>
<td style="text-align:left">保存和检索输入输出的FlashMap，它可以将属性从一个请求传递到另一个请求的输入输出，一般应用在重定向中。 </td>
</tr>
</tbody>
</table>
<h5 id="Web-MVC-配置"><a href="#Web-MVC-配置" class="headerlink" title="Web MVC 配置"></a>Web MVC 配置</h5><p>应用可以声明在特殊的bean类型中列出的bean来处理请求。<code>DispatcherServlet</code>会检查每一个bean的<code>WebApplicationContext</code>。如果没有指定的bean，那么就会使用DispatcherServlet.properties中定义的bean。<br>MVC配置将会在以后详细的列出。</p>
<h5 id="Servlet-配置"><a href="#Servlet-配置" class="headerlink" title="Servlet 配置"></a>Servlet 配置</h5><p>在Servlet 3.0+中，可以使用编程的方式来代替web.xml配置。下面这个例子就是通过编程注册<code>DispatcherServlet</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</div><div class="line">        XmlWebApplicationContext appContext = <span class="keyword">new</span> XmlWebApplicationContext();</div><div class="line">        appContext.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</div><div class="line"></div><div class="line">        ServletRegistration.Dynamic registration = container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet(appContext));</div><div class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</div><div class="line">        registration.addMapping(<span class="string">"/"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>WebApplicationInitializer</code>是由SpringMVC提供的接口，用来保证上述实现可以由支持Servlet 3.0的容器自动检测并初始化。抽象类<code>AbstractDispatcherServletInitializerl</code>实现了<code>WebApplicationInitializer</code> 可以更加容易的注册<code>DispathcerServlet</code>。<br>下面是使用Java配置的Spring<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; MyWebConfig.class &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用的是xml配置，需要直接继承<code>AbstractDispatcherServletInitializer</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createServletApplicationContext</span><span class="params">()</span> </span>&#123;</div><div class="line">        XmlWebApplicationContext cxt = <span class="keyword">new</span> XmlWebApplicationContext();</div><div class="line">        cxt.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</div><div class="line">        <span class="keyword">return</span> cxt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>AbstractDispatcherServletInitializer</code>同样提供了一个方便的函数来添加过滤器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Filter[] &#123;</div><div class="line">            <span class="keyword">new</span> HiddenHttpMethodFilter(), <span class="keyword">new</span> CharacterEncodingFilter() &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个过滤器根据他具体的类型添加一个默认的名字，并且自动映射到DispatcherServlet。<br><code>isAsyncSupported</code>方法是<code>AbstractDispatcherServletInitializer</code>的protect的方法，可以启动<code>DispatcherServlet</code>支持异步处理<br>如果要定义自己的DispatcherServlet，那么可以重写<code>createDispatcherServlet</code>方法。</p>
<h5 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h5><p><code>DispatcherServlet</code>处理请求的流程如下：  </p>
<ul>
<li>查找<code>WebApplicationContext</code>并将其作为request的一个属性保存起来，以便其他控制器或者处理链中的组件可以使用。默认保存键为<code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> </li>
<li>本地化解析器保存在request中，以便处理链中的其他组件使用他来处理请求做本地化处理。如果不需要本地化，那么就不需要使用他。</li>
<li>主题解析器保存在request中，以便其他组件，例如视图查找器使用，如果不需要要主题定制，直接忽略。</li>
<li>如果指定了文件上传解析器，那么就会检查请求是否有文件上传，如果有请求有<code>MultipartHttpServletRequest</code>封装，以便其他组件处理。</li>
<li>查找合适的处理器处理请求。如果找到了处理器，那么就依次执行处理链上的组件，返回一个model或者视图。如果是注解的controller也可以直接渲染而不需要返回视图。</li>
<li>如果返回一个model，会渲染一个视图，如果没有返回model，那么就无需渲染视图了，因为视图可能已经被渲染了。</li>
</ul>
<p>在请求处理过程中如果出现了一场那么就可以使用<code>WebApplicatioContext</code>中的<code>HandlerExceptionResolver</code>来定制异常处理。<br>SpringMVC 同样支持返回<code>last-modification-date</code>，对指定请求处理如何判断是否有<code>last-modification-date</code>非常直接：<code>DispatcherServlet</code>查找适合的处理器，并且检查其是否实现了<code>LastModified</code>接口，如果实现了，调用<code>long getLastModified(request)</code>返回给客户端。<br>通过web.xml中Servlet的初始化参数可以定制DispatcherServlet.</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">contextClass</td>
<td style="text-align:left">实现<code>WebApplicationContext</code>的类，默认使用<code>XmlWebApplicationContext</code> </td>
</tr>
<tr>
<td style="text-align:left">contextConfigLocation</td>
<td style="text-align:left">传递给Context 实例的字符串，包括了bean的定义 </td>
</tr>
<tr>
<td style="text-align:left">namespace</td>
<td style="text-align:left"><code>WebApplicationContext</code> 的命名空间，默认<code>[servlet-name]-servlet</code> </td>
</tr>
</tbody>
</table>
<h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><p><code>HandlerMapping</code>支持拦截器，在对某些请求添加处理的时候非常有用，比如，权限检查。拦截器必须实现<code>org.springframework.web.servlet</code>包中的<code>HandlerInterceptor</code>，这个接口有三个处理函数分别对应请求处理前，请求处理后，完成请求处理。</p>
<ul>
<li>preHandle(..) 在请求处理前执行</li>
<li>postHandle(..) 请求处理后执行</li>
<li>afterCompletion(..) 整个请求处理结束后执行<br><code>preHandle(..)</code> 返回一个boolean值。可以使用这个值来中断处理请求链。当返回true的时候，处理将会继续执行，如果返回false，<code>DispatcherServelt</code>假定拦截器已经对请求正确处理了，例如渲染了一个页面等。将会中断请求处理链。<br>注意，<code>postHandle</code>方法很少使用<code>@ResponseBody</code>和<code>ResponseEntity</code>。因为响应已经在<code>postHandle</code>执行之前有<code>HandlerAdapter</code>返回了。意味着在<code>postHandle</code>的时候再修改响应已经晚了。对应这种场景可以继承<code>ResponseBodyAdvice</code>或者实现ControllerAdvice或者直接配置<code>RequestMappingHandlerAdapter</code>来实现。</li>
</ul>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>如果在请求映射或者处理请求的时候抛出异常，<code>DispatcherServelt</code>会委托<code>HandlerExceptionResolver</code>来解析异常并提供可选择的处理，即返一个错误响应。<br>下表是<code>HandlerExceptionResolver</code>的实现</p>
<table>
<thead>
<tr>
<th style="text-align:left">HandlerExceptionResolver</th>
<th style="text-align:left">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SimpleMappingExceptionResolver</td>
<td style="text-align:left">异常类名和错误页面名的映射。浏览器渲染错误页面的时候非常实用 </td>
</tr>
<tr>
<td style="text-align:left">DefaultHandlerExceptionResolver</td>
<td style="text-align:left">解析SpringMVC抛出的异常，同时将其映射到HTTP的错误码上  </td>
</tr>
<tr>
<td style="text-align:left">ResponseStatusExceptionResolver</td>
<td style="text-align:left">解析@ResponseStatus注解，同时根据其注解值将其映射到HTTP的错误码上  </td>
</tr>
<tr>
<td style="text-align:left">ExceptionHandlerExceptionResolver</td>
<td style="text-align:left">调用@Controller 或者@ControllerAdvice 类中使用@ExceptionHandler注解的方法 </td>
</tr>
</tbody>
</table>
<h6 id="解析链"><a href="#解析链" class="headerlink" title="解析链"></a>解析链</h6><p>可以通过在Spring的配置中声明多个<code>HandlerExceptionResolver</code>bean，来构成一个异常处理解析链，如果需要的话，同时可以设置他们解析的顺序。序号越大，处理越靠后。<br><code>HandlerExceptionResolver</code>可以返回：</p>
<ul>
<li>指向错误页面的 <code>ModelAndView</code></li>
<li>如果异常在解析链中被处理返回空<code>ModelAndView</code></li>
<li>如果异常为被处理返回<code>null</code>，后续的解析起继续处理异常，如果异常一直未被处理，那么将会冒泡到Servlet容器处理<br>Spring MVC的异常是有MVC配置自动声明的，@ResponseStatus注解异常，支持@ExceptionHandler方法的异常。这些处理器都是可以定制和替换的<h6 id="Servlet容器异常"><a href="#Servlet容器异常" class="headerlink" title="Servlet容器异常"></a>Servlet容器异常</h6>如果<code>HandlerExceptionResolver</code>无法处理异常，那么异常将会继续传播，或者是返回了错误的HTTP状态码，例如4xx，5xx。Servlet容器可能会渲染一个错误的页面。这个页面也是可以定制的：<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>根据上述代码，当出现了无法处理的异常，或者返回错误码，容器会根据配置返回一个错误的URL。这个请求将会继续被DispatcherServlet处理，比如映射到一个@Controller的错误处理控制器上：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/error"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">handle</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">        map.put(<span class="string">"status"</span>, request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>));</div><div class="line">        map.put(<span class="string">"reason"</span>, request.getAttribute(<span class="string">"javax.servlet.error.message"</span>));</div><div class="line">        <span class="keyword">return</span> map;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="视图解析"><a href="#视图解析" class="headerlink" title="视图解析"></a>视图解析</h5><p>Spring MVC通过定义了<code>ViewResolver</code>和<code>View</code>两个接口可以让我们直接通过返回model来渲染视图，而不需要指定某一个特定的视图技术。<code>ViewResolver</code>提供了视图名和视图之间的映射关系。在提交给特定视图技术之前由<code>View</code>来准备数据。<br>下列表格展示了ViewResolver的层级：</p>
<table>
<thead>
<tr>
<th style="text-align:left">ViewResolver</th>
<th style="text-align:left">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AbstractCachingViewResolver</td>
<td style="text-align:left">缓存解析过的视图。可设置cache属性为false来关闭缓存。在需要刷新缓存的场景可调用<code>removeFromCache(String viewName, Locale loc)</code>刷新。</td>
</tr>
<tr>
<td style="text-align:left">XmlViewResolver</td>
<td style="text-align:left">实现<code>ViewResolver</code>，可以接收一个同Spring XML bean同DTD的xml配置文件。默认在/WEB-INF/views.xml</td>
</tr>
<tr>
<td style="text-align:left">ResourceBundleViewResolver</td>
<td style="text-align:left">解析定义在<code>ResourceBundle</code>中的视图，使用viewname.class作为视图类，viewname.url作为视图名</td>
</tr>
<tr>
<td style="text-align:left">UrlBasedViewResolver</td>
<td style="text-align:left">无需明确指定映射，直接通过解析url来查找视图名。</td>
</tr>
<tr>
<td style="text-align:left">InternalResourceViewResolver</td>
<td style="text-align:left">实现<code>UrlBasedViewResolver</code>,<code>JstlView</code>,<code>TilesView</code>，支持<code>InternalResourceView</code>例如：jsp，servlet class等。</td>
</tr>
<tr>
<td style="text-align:left">FreeMarkerViewResolver</td>
<td style="text-align:left"><code>UrlBasedViewResolver</code>的子类，用来支持FreeMarker</td>
</tr>
<tr>
<td style="text-align:left">ContentNegotiatingViewResolver</td>
<td style="text-align:left">根据请求的文件名或者Accept来确定视图</td>
</tr>
</tbody>
</table>
<h6 id="视图处理"><a href="#视图处理" class="headerlink" title="视图处理"></a>视图处理</h6><p>如果需要的话，可以声明多个视图处理器，通过设置<code>order</code>属性来确定他们的顺序。order越大，处理越靠后。<br>默认情况下<code>ViewResolver</code>可以返回null代表找不到视图。当然在JSP中，使用InternalResourceViewResolver来检查JSP是否存在的唯一方式就是通过<code>RequestDispatcher</code>执行一次调度。因此<code>InternalResourceViewResolver</code>必须是最后一个视图解析器。</p>
<h6 id="视图redirect"><a href="#视图redirect" class="headerlink" title="视图redirect"></a>视图redirect</h6><p>视图前缀<code>redirect:</code> 表示视图需要执行一次redirect。<code>UrlBasedViewResolver</code>和其子类会识别出这是要给重定向，剩下的部分就是视图名。<br>这个效果和Controller返回一个<code>RedirectView</code>一样，但是使用这个指令，controller就可以简单的返回一个视图名就可以了。视图名<code>redirect:/myapp/some/resource</code>将会返回相对于当前Servlet Context的视图，<code>redirect:http://myhost.com/some/arbitrary/path</code> 这种则会返回绝对URL。<br>注意，如果一个controller被<code>@ResponseStatus</code>修饰，那么注解值优先级高于<code>RedirectView</code></p>
<h6 id="视图Forwarding"><a href="#视图Forwarding" class="headerlink" title="视图Forwarding"></a>视图Forwarding</h6><p>视图前缀<code>forward:</code>表示视图执行forwarding。同样由<code>UrlBasedViewResolver</code>和其子类解析。通过创建<code>InternalResourceView</code>执行<code>RequestDispatcher.forward()</code>实现。因此这个指令对于<code>InternalResourceViewResolver</code>和<code>InternalResourceViewResolver</code>没啥用，但是对于使用了其他的视图技术但是仍然想用强制使用JSP或者Servlet的时候就很有用了。</p>
<h6 id="视图内容协商"><a href="#视图内容协商" class="headerlink" title="视图内容协商"></a>视图内容协商</h6><p><code>ContentNegotiatingViewResolver</code>并不会解析视图，而是将其委托给其他视图解析器，并且选择客户端请求描述选择视图。描述可以是Accept头或者参数，例如<code>/path?format=pdf</code><br><code>ContentNegotiatingViewResolver</code>通过对比请求的媒体类型和<code>ViewResolvers</code>支持的媒体类型来选择合适的View。被选中的列表中的第一个View将会被返回给客户端。</p>
<h5 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h5><p>同Spring MVC，大多数Spring架构支持国际化。<code>DispatcherServlet</code>通过<code>LocaleResolver</code>根据客户端的区域自动解析消息。<br>当请求到来时<code>DispatcherServlet</code>查找本地化解析器，如果找到则会设置本地化。通过<code>RequestContext.getLocale()</code>方法可以获取由本地化解析器解析的本地化语言。<br>为了自动化解析，可以通过拦截器对具体的场景进行本地化解析，例如根据请求参数来解析。<br>本地化解析器和拦截器定义在<code>org.springframework.web.servlet.i18n</code>包中，可以在应用中配置。下面是一些Spring使用的配置</p>
<h6 id="TimeZone"><a href="#TimeZone" class="headerlink" title="TimeZone"></a>TimeZone</h6><p>通过获取客户端的时区来做本地化。<code>LocaleContextResolver</code>接口扩展了<code>LocalResolver</code>，提供了一个可能包含时区信息的<code>LocaleContext</code>。<br>如果可以，用户的时区可以通过<code>RequestContext.getTimeZone()</code>方法获取。时区信息可以自动的被注册到Spring中的ConversionService 日期时间的Converter和Formatter使用。</p>
<h6 id="Header-resolver"><a href="#Header-resolver" class="headerlink" title="Header resolver"></a>Header resolver</h6><p>这个解析器检查<code>accept-language</code>头，一般来说包含的是客户端操作系统的区域。注意这个不支持时区。</p>
<h6 id="Cookie-resolver"><a href="#Cookie-resolver" class="headerlink" title="Cookie resolver"></a>Cookie resolver</h6><p>这个解析器检查cookie中可能包含的<code>TimeZone</code>和<code>Locale</code>。通过如下定义来使用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookieName"</span> <span class="attr">value</span>=<span class="string">"clientlanguage"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookieMaxAge"</span> <span class="attr">value</span>=<span class="string">"100000"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>CookieLocaleResolver的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名字</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cookieName</td>
<td style="text-align:left">classname + LOCALE</td>
<td style="text-align:left">cookie名</td>
</tr>
<tr>
<td style="text-align:left">cookieMaxAge</td>
<td style="text-align:left">Servlet容器默认值</td>
<td style="text-align:left">cookie生效时间</td>
</tr>
<tr>
<td style="text-align:left">cookiePath</td>
<td style="text-align:left">/</td>
<td style="text-align:left">cookie 保存位置</td>
</tr>
</tbody>
</table>
<h6 id="Session-resolver"><a href="#Session-resolver" class="headerlink" title="Session resolver"></a>Session resolver</h6><p><code>SessionLocaleResolver</code>通过从session中检查可能包含的<code>TimeZone</code>和<code>Locale</code>。相对于<code>CookieLocaleResolver</code>，他将信息保存在<code>HttpSession</code>中。</p>
<h6 id="Locale-interceptor"><a href="#Locale-interceptor" class="headerlink" title="Locale interceptor"></a>Locale interceptor</h6><p>可以通过拦截器启动针对某些映射的本地化策略，例如如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeChangeInterceptor"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"paramName"</span> <span class="attr">value</span>=<span class="string">"siteLanguage"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"urlMapping"</span></span></div><div class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptors"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"localeChangeInterceptor"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/**/*.view=someController<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h5><p>可以通过设置Spring MVC的主题来整体设置应用的外观，从而提高用户体验。主题是一些静态资源的集合，主要是可以影响外观的样式表和图片。<br>为了应用主题，首先要设置一个<code>org.springframework.ui.context.ThemeSource</code>的接口。<code>WebApplicationContext</code>继承了<code>ThemeSource</code>，但是将其实现委托给了子类。默认使用的是<code>org.springframework.ui.context.support.ResourceBundleThemeSource</code>来从classpath的根目录下加载配置文件。配置文件格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">styleSheet=/themes/cool/style.css</div><div class="line">background=/themes/cool/img/coolBg.jpg</div></pre></td></tr></table></figure></p>
<p>配置文件的名字是视图代码中的变量名。对于JSP而言可以如下显示：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;link rel="stylesheet" href="&lt;spring:theme code='styleSheet'/&gt;" type="text/css"/&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body style="background=&lt;spring:theme code='background'/&gt;"&gt;</div><div class="line">        ...</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>默认情况下<code>ResourceBundleThemeSource</code>使用空的前缀名，这样配置文件直接从classpath根目录下加载。这样就可以将<code>cool.properties</code>定义放到classpath根目录下，<code>ResourceBundleThemeSource</code>默认使用标准的Java资源加载工具，同时也完全支持国际化，所以通过命名来支持<code>cool_nl.properties</code>。</p>
<h6 id="解析主题"><a href="#解析主题" class="headerlink" title="解析主题"></a>解析主题</h6><p><code>DispatcherServlet</code>通过bean的名字<code>themeResolver</code>来查找<code>ThemeResolver</code>的实现。<br>ThemeResolver 的实现如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Class</th>
<th style="text-align:left">描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FixedThemeResolver</td>
<td style="text-align:left">选中一个固定的主题，设置<code>defaultThemeName</code>属性</td>
</tr>
<tr>
<td style="text-align:left">SessionThemeResolver</td>
<td style="text-align:left">主题由用户session维护。每个session只需要设置一次</td>
</tr>
<tr>
<td style="text-align:left">CookieThemeResolver</td>
<td style="text-align:left">通过cookie选择主题</td>
</tr>
</tbody>
</table>
<h5 id="Multipart-resolver"><a href="#Multipart-resolver" class="headerlink" title="Multipart resolver"></a>Multipart resolver</h5><p><code>org.springframework.web.multipart</code>中的<code>MultipartResolver</code>是用来处理multipart请求的。共有给予Common Fileupload和Servlet 3.0 两种实现。<br>为了使用multipart，需要在<code>DispatcherServlet</code>的Spring配置中声明一个名字为<code>multipartResolver</code>的bean。当POST请求的<code>content-type</code>是<code>multipart/form-data</code>的时候，解析器解析这个请求并且将<code>HttpServletRequest</code>封装成<code>MultipartHttpServletRequest</code>来处理请求。</p>
<h6 id="Apache-FileUpload"><a href="#Apache-FileUpload" class="headerlink" title="Apache FileUpload"></a>Apache FileUpload</h6><p>使用Apache Commons FileUpload 只需要简单的配置一个类型为<code>CommonsMultipartResolver</code>，名字为<code>multipartResolver</code>的bean即可。当然也需要将<code>commons-fileupload</code>加入到依赖中。</p>
<h6 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a>Servlet 3.0</h6><p>使用Servlet 3.0则需要Servlet 容器的配置</p>
<ul>
<li>使用Java配置，在Servlet注册中设置<code>MultipartConfigElement</code>。</li>
<li>使用web.xml 添加要给<code>&lt;multipart-config&gt;</code>的配置<br>如下是使用Java的配置：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold</span></div><div class="line">        registration.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(<span class="string">"/tmp"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Servlet 3.0配置好之后，只需要添加类型为<code>StandardServletMultipartResolver</code>，名字为<code>multipartResolver</code>的配置即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;p&gt;同许多其他的web框架一样，SpringMVC使用了前端控制器的设计模式，即一个以&lt;code&gt;DispatcherServlet&lt;/code
    
    </summary>
    
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="SpringMVC" scheme="https://mashuai.github.io/tags/SpringMVC/"/>
    
      <category term="Spring" scheme="https://mashuai.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>8个关键的应用性能指标</title>
    <link href="https://mashuai.github.io/2018/04/07/8-key-application-metrics/"/>
    <id>https://mashuai.github.io/2018/04/07/8-key-application-metrics/</id>
    <published>2018-04-06T16:39:10.000Z</published>
    <updated>2018-04-13T06:22:19.416Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://stackify.com/application-performance-metrics/" target="_blank" rel="external">原文地址</a>  </p>
<h5 id="用户满意度-Apdex-分数"><a href="#用户满意度-Apdex-分数" class="headerlink" title="用户满意度/Apdex 分数"></a>用户满意度/Apdex 分数</h5><p>应用性能指数或者Apdex分数，已经变成追踪应用反应性能的工业标准。<br>通过定义指标：一个指定的web请求或者事务达到这个指标的时间是多久。<br>这些事务可以被分为满意（快），可容忍（慢），太慢，请求失败。可以用下面这个简单的数学公式来表示，分数范围从0到1.<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/img_58a9f75d0a12a.png" alt="apdex score"></p>
<h5 id="平均响应时间"><a href="#平均响应时间" class="headerlink" title="平均响应时间"></a>平均响应时间</h5><p>首先先说明一点，平均非常傻。非常推荐使用上述的用户满意度Apedx分数来追踪性能问题。平均响应时间有时仍然是一个有用的指标。</p>
<h5 id="错误率"><a href="#错误率" class="headerlink" title="错误率"></a>错误率</h5><p>最不想用户看到的就是错误。监控错误率是一个应用的重要性能指标。<br>主要有以下三种错误：</p>
<ul>
<li>HTTP 错误-web请求错误的个数</li>
<li>日志异常： 在应用中未处理的，打印出来的异常日志</li>
<li>抛出异常： 所有抛出的异常<h5 id="应用实例的个数"><a href="#应用实例的个数" class="headerlink" title="应用实例的个数"></a>应用实例的个数</h5>如果应用是部署在云上。那么就知道你的服务器/应用实例到底有多少在运行就很重要了。自动伸缩可以帮助应用按需伸缩同时也能在飞峰值时节省资源。<h5 id="请求率"><a href="#请求率" class="headerlink" title="请求率"></a>请求率</h5>了解你的应用接收了多少流量对你应用的成功有显著的影响。一般来说其他的性能指标都被流量的增加和减少所影响。<br>请求率可以很容易的和其他的性能指标结合起来显示出你的应用时如何动态扩展的。<br>监控请求率可以很好的监控峰值或者低谷。如果你有一个频繁访问的API，突然一点流量都没有了，那么这就需要小心了。<br>一个相似，但是略有不同的指标就是追踪并发用户量。<h5 id="应用和服务器CPU"><a href="#应用和服务器CPU" class="headerlink" title="应用和服务器CPU"></a>应用和服务器CPU</h5>如果CPU使用率特别高，那么应用肯定有性能问题。监控CPU使用是服务器和应用最基本也是最重要的指标。<br>几乎所有的服务器或者应用监控工具都能追踪CPU使用，同时提供告警。对每一台服务器追踪他们的CPU使用率是很重要的，同样重要的是追踪一个应用的一组CPU的使用率。<h5 id="应用可用性"><a href="#应用可用性" class="headerlink" title="应用可用性"></a>应用可用性</h5>监控应用是否在线和可用是一个关键的指标。<br>如果是一个Web应用，最简单的方式就是设置几个定时任务来检查HTTP，是否可用。<h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5>如果使用的是Java相关语言，则需要注意垃圾回收器的效率。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://stackify.com/application-performance-metrics/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;  &lt;/p&gt;
&lt;h5 id=&quot;用户满意度-Apdex-分数&quot;&gt;&lt;a 
    
    </summary>
    
    
      <category term="APM" scheme="https://mashuai.github.io/tags/APM/"/>
    
      <category term="Performance" scheme="https://mashuai.github.io/tags/Performance/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Spring MVC</title>
    <link href="https://mashuai.github.io/2018/04/07/deep-in-spring-mvc/"/>
    <id>https://mashuai.github.io/2018/04/07/deep-in-spring-mvc/</id>
    <published>2018-04-06T16:39:10.000Z</published>
    <updated>2018-04-17T01:47:30.617Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://stackify.com/spring-mvc/" target="_blank" rel="external">原文地址</a>  </p>
<h5 id="初始工程"><a href="#初始工程" class="headerlink" title="初始工程"></a>初始工程</h5><p>这篇文章中将使用最新的Spring Framework 5框架。主要关注的是Spring的经典Web技术栈，这套技术从最开始的Spring版本就开始支持，并且知道现在仍然是构建Spring Web应用的主要方式。<br>使用Spring Boot和其他starter来设置初始工程。xml配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h5><p>为了理解Spring Web MVC是如何工作的，可以先实现一个简单的Login功能的。创建一个由<code>@Controller</code>来修饰的类<code>InternalController</code>，这个类包含一个Get的映射。<br><code>hello()</code>函数没有参数。返回一个由Spring解释的视图名字的字符串。（在本例中是<code>login.html</code>）  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</div><div class="line"></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"login"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了处理用户登陆逻辑，创建另一个接受POST请求的带有Login数据的方法。然后根据处理结果返回成功或者失败页面。<br>注意，<code>login()</code>函数接受一个领域对象作为参数，返回的是<code>ModelAndView</code>对象。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(LoginData loginData)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (LOGIN.equals(loginData.getLogin()) </div><div class="line">      &amp;&amp; PASSWORD.equals(loginData.getPassword())) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"success"</span>, </div><div class="line">          Collections.singletonMap(<span class="string">"login"</span>, loginData.getLogin()));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"failure"</span>, </div><div class="line">          Collections.singletonMap(<span class="string">"login"</span>, loginData.getLogin()));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ModelAndView</code>保存了两个不同的对象：</p>
<ul>
<li>Model： 用来渲染页面用的键值对的map</li>
<li>View： 填充Model数据的模版页面。  </li>
</ul>
<p>将它们合并起来是为了方便，这样controller的方法就可以同时返回这两个了。<br>使用<code>Thymeleaf</code>作为模版引擎来渲染页面。  </p>
<h5 id="Java-Web应用的基础-Servlet"><a href="#Java-Web应用的基础-Servlet" class="headerlink" title="Java Web应用的基础-Servlet"></a>Java Web应用的基础-Servlet</h5><p>当你在浏览器里键入<code>http://localhost:8080/</code>，然后按回车键，请求到达服务器的时候到底发生了什么？是如何在浏览器中看到这个web请求的数据的？<br>因为这个项目是一个简单的Spring Boot应用，所以可以通过<code>Spring5Application</code>来运行。<br>Spring Boot默认使用<a href="http://stackify.com/tomcat-performance-monitoring/" target="_blank" rel="external">Apache Tomcat</a>运行程序，运行成功后可能会看到如下的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">2017-10-16 20:36:11.626  INFO 57414 --- [main] </div><div class="line">  o.s.b.w.embedded.tomcat.TomcatWebServer  : </div><div class="line">  Tomcat initialized with port(s): 8080 (http)</div><div class="line">  </div><div class="line">2017-10-16 20:36:11.634  INFO 57414 --- [main] </div><div class="line">  o.apache.catalina.core.StandardService   : </div><div class="line">  Starting service [Tomcat]</div><div class="line"></div><div class="line">2017-10-16 20:36:11.635  INFO 57414 --- [main] </div><div class="line">  org.apache.catalina.core.StandardEngine  : </div><div class="line">  Starting Servlet Engine: Apache Tomcat/8.5.23</div></pre></td></tr></table></figure>
<p>因为Tomcat是一个Servlet容器，所以几乎所有的HTTP请求都是由Java Servlet处理的。自然的Spring Web的入口就是一个Servlet。<br>Servlet是所有Java Web应用的核心组件；它非常的低成，并且没有暴露任何具体的编程模式，例如MVC。<br>一个HTTP的Servelt只能接受HTTP请求，处理请求后返回响应。<br>现在使用Servlet 3.0的API，可以不再使用XML配置，直接可以使用Java配置。</p>
<h5 id="Spring-MVC的核心-DispatcherServlet"><a href="#Spring-MVC的核心-DispatcherServlet" class="headerlink" title="Spring MVC的核心-DispatcherServlet"></a>Spring MVC的核心-DispatcherServlet</h5><p>作为Web开发者，我们希望抽象出以下枯燥和样板的任务，而关注于有用的业务逻辑  </p>
<ul>
<li>将HTTP请求映射到响应处理函数</li>
<li>将HTTP请求数据和header解析成数据传输对象（DTOs）或者领域对象</li>
<li>model-view-controller 互相交互</li>
<li>从DTO，领域对象等生成响应  </li>
</ul>
<p>Spring的<code>DispatcherServlet</code>提供了以上的功能，是Spring WEB MVC框架的核心，是应用接受所有请求的核心组件。<br>稍后就会了解到<code>DispatcherServlet</code>可扩展性非常强。例如：它允许你加入现有或者新的适配器来适应不同的任务：</p>
<ul>
<li>将请求映射到处理它的类或者函数(由<code>HandlerMapping</code>实现）</li>
<li>使用特定模式来处理请求，例如一个普通的Servlet，一个复杂的MVC 工作流，或者只是一个方法。(由<code>HandlerAdapter</code>实现）</li>
<li>通过名字解析试图对象，允许你使用不同的模版引擎，例如：XML，XSLT或者其他视图技术(由<code>ViewResolver</code>实现）</li>
<li>默认使用Apache Comons 的文件上传组件解析文件上传，或者也可以自己实现。</li>
<li>由<code>LocalResolver</code>实现本地化，包括cookie，session，HTTP的Accept Header，或者其他由用户定义的本地化。    </li>
</ul>
<h5 id="处理HTTP请求"><a href="#处理HTTP请求" class="headerlink" title="处理HTTP请求"></a>处理HTTP请求</h5><p>首先让我们重新审视一下在刚刚建立的应用中是如何处理HTTP请求的。<br><code>DispatcherServlet</code>有一个很长的继承层级。自顶向下理解每个单独的概念是非常有必要的。处理请求的函数将会更加有趣。<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/springmvc.png" alt="SpringMVC"><br>理解HTTP请求在本地开发模式处理和远程处理是理解MVC架构非常重要的一步。</p>
<h6 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h6><p><code>GenericServlet</code>时Servlet规范中的一部分，不直接处理HTTP。它定义了<code>service()</code>方法，来接受请求和返回响应。<br>注意，<code>ServletRequest</code>和<code>ServletResponse</code>并不是绑定到HTTP协议的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> </span></div><div class="line">  <span class="keyword">throws</span> ServletException, IOException;</div></pre></td></tr></table></figure></p>
<p>服务器所有的请求，包括简单的GET请求都会调用这个方法。</p>
<h5 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h5><p>正如其名，<code>HttpServelt</code>是Servlet 规范中关于HTTP请求的实现。<br>更确切的说，<code>HttpServlet</code>是一个实现了<code>service()</code>的抽象类。通过将不同的HTTP请求类型分开，由不同的函数处理，实现大约如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    String method = req.getMethod();</div><div class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        doGet(req, resp);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        doHead(req, resp);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</div><div class="line">        doPost(req, resp);</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h5 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h5><p>在这个继承关系中<code>HttpServletBean</code>是第一个Spring的类。从web.xml或者WebApplicationInitialzer获取的初始参数来注入bean。<br>在应用中的请求分别调用doGet,doPost等方法来处理不同的HTTP请求。</p>
<h5 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h5><p><code>FrameworkServlet</code>实现了<code>ApplicationContextAware</code>,集成Web的Application Context。不过它也可以创建自己的Application Context。<br>正如上述所言，父类<code>HttpServletBean</code>通过将初始参数作为bean的属性注入。因此如果contex的类名在<code>contextClass</code>这个初始参数中，那么就有这个参数创建application context的实例，否则默认使用<code>XmlWebApplicationContext</code>。<br>由于XML配置现在已经过时了。Spring Boot默认使用<code>AnnotationConfigWebApplicationContext</code>来配置<code>DispatcherServlet</code>。不过这个是很容易修改的。<br>例如，想要在Spring MVC中使用Groovy的application context，可以将下列配置在web.xml中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatcherServlet</div><div class="line">      org.springframework.web.servlet.DispatcherServlet</div><div class="line">      contextClass</div><div class="line">      org.springframework.web.context.support.GroovyWebApplicationContext</div></pre></td></tr></table></figure></p>
<p>相同的配置也可以在<code>WebApplicationInitializer</code>中配置。</p>
<h5 id="DispatcherServlet-统一处理请求"><a href="#DispatcherServlet-统一处理请求" class="headerlink" title="DispatcherServlet: 统一处理请求"></a>DispatcherServlet: 统一处理请求</h5><p><code>HttpServlet.service()</code>通过HTTP的动词类型来处理路由不同的请求到不同的方法，这个在底层的servlet实现的很好。但是，在SpringMVC的抽象层次中，不能仅靠方法类型来路由请求。<br>同样的，<code>FrameworkServlet</code>的另一个主要功能就是将不同的处理使用<code>processRequest()</code>组合在一起。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">  HttpServletResponse response) <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">    processRequest(request, response);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">  HttpServletResponse response) <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">    processRequest(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="DispatcherServlet-丰富请求"><a href="#DispatcherServlet-丰富请求" class="headerlink" title="DispatcherServlet: 丰富请求"></a>DispatcherServlet: 丰富请求</h5><p>最后,<code>DispatcherServlet</code>实现<code>doService()</code>方法。它向请求中加入了一些有用的对象，继续在web 的管道中传递下去，例如：web application context, locale resolver, theme resolver, theme source等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, </div><div class="line">  getWebApplicationContext());</div><div class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</div><div class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</div><div class="line">request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</div></pre></td></tr></table></figure></p>
<p>同时，<code>doService()</code>加入了输入输出的Flash Map，Flash Map是将参数从一个请求传递到另一个请求的基本模式。在重定向中很有用。(例如在重定向之后向用户展示一段简单的信息）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager</div><div class="line">  .retrieveAndUpdate(request, response);</div><div class="line"><span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</div><div class="line">    request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, </div><div class="line">      Collections.unmodifiableMap(inputFlashMap));</div><div class="line">&#125;</div><div class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</div></pre></td></tr></table></figure></p>
<p>接着<code>doService()</code>将会调用<code>doDispatch()</code>方法来分发请求。</p>
<h5 id="DispatcherServlet-分发请求"><a href="#DispatcherServlet-分发请求" class="headerlink" title="DispatcherServlet: 分发请求"></a>DispatcherServlet: 分发请求</h5><p><code>dispatch()</code>的主要目的就是知道一个合适的处理请求的处理器并且传递request/response参数。处理器可以是任何对象，并不局限于一个特定的接口。同样也意味着Spring需要找到如何使用这个处理器的适配器。<br>为了给请求找到合适的处理器，Spring会遍历实现<code>HandlerMapping</code>接口的注册的实现。有很多不同的实现可以满足我们各种需求。<br><code>SimpleUrlHandlerMapping</code>使用URL将请求映射到处理bean中。例如：它可以通过<code>Java.util.Properties</code>注入它的映射信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/welcome.html=ticketController</div><div class="line">/show.html=ticketController</div></pre></td></tr></table></figure></p>
<p><code>RequestMappingHandlerMapping</code>可能是最广泛使用的映射处理器。它将请求映射到<code>@Controller</code>类下的<code>@RequestMapping</code>修饰的方法上。这个就是上面那个例子中的<code>hello()</code>和<code>login()</code>。<br>注意，上面两个方法分别是<code>@GetMapping</code>和<code>@PostMapping</code>修饰的。这两个注解来源于<code>@RequestMapping</code>。<br><code>dispatch()</code>同时也可以处理一些其他的HTTP的任务：</p>
<ul>
<li>如果资源不存在，对GET请求进行短路处理。</li>
<li>对相应的请求使用multipart 解析。</li>
<li>如果处理器选择异步处理请求，对请求进行短路处理。  </li>
</ul>
<h5 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h5><p>现在Spring确定了处理请求的处理器和处理器的适配器，是时候处理请求了。下面是<code>HandlerAdapter.handle()</code>的签名。比较重要的一点是处理器可以选择如何处理请求：</p>
<ul>
<li>直接将相应写入到response body 和 返回null</li>
<li>返回一个<code>ModelAndView</code>对象由<code>DispatcherServlet</code>渲染。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">                    HttpServletResponse response, </div><div class="line">                    Object handler) <span class="keyword">throws</span> Exception;</div></pre></td></tr></table></figure>
<p>Spring提供了很多类型的处理器，下面是<code>SimpleControllerHandlerAdapter</code>如何处理Spring MVC的controller实例的(不要和@Controller搞混)。<br>注意，controller处理器返回ModelAndView对象并不是由起渲染的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">  HttpServletResponse response, Object handler) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    <span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个是<code>SimpleServletHandlerAdapter</code>它对一个普通的servlet适配。<br>servlet并不知道<code>ModelAndView</code>，完全自己处理请求，将返回写入到相应的body中。因此它的适配器就直接返回null。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, </span></span></div><div class="line">  HttpServletResponse response, Object handler) <span class="keyword">throws</span> Exception &#123;</div><div class="line">    ((Servlet) handler).service(request, response);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在本例中，controller是由<code>@RequestMapping</code>修饰的POJO，因此处理器会使用<code>HandlerMethod</code>来封装它的方法。Spring使用<code>RequestMappingHandlerAdapter</code>来适配这种处理器类型。</p>
<h5 id="处理参数，返回处理器函数的值"><a href="#处理参数，返回处理器函数的值" class="headerlink" title="处理参数，返回处理器函数的值"></a>处理参数，返回处理器函数的值</h5><p>注意，一般来说controller并不会接收<code>HttpServletRequest</code>和<code>HttpServletResponse</code>作为参数，但是它可以接收和返回很多中其他类型，例如：领域对象，路径参数等。<br>同样，也不强求一个controller返回一个<code>ModelAndView</code>实例。可以选择返回一个视图名称，<code>ResponseEntity</code>，或者是一个可以被转换成JSON的POJO。<br><code>RequestMappingHandlerAdapter</code>可以保证从<code>HttpServletRequest</code>中解析方法需要的参数，同时创建<code>ModelAndView</code>对象返回。<br>下面这段代码就是<code>RequestMappingHandlerAdapter</code>中保证这件事情的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ServletInvocableHandlerMethod invocableMethod </div><div class="line">  = createInvocableHandlerMethod(handlerMethod);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</div><div class="line">    invocableMethod.setHandlerMethodArgumentResolvers(</div><div class="line">      <span class="keyword">this</span>.argumentResolvers);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</div><div class="line">    invocableMethod.setHandlerMethodReturnValueHandlers(</div><div class="line">      <span class="keyword">this</span>.returnValueHandlers);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>argumentResolvers</code>在<code>HandlerMethodArgumentResolver</code>实例中有不同实现。一共有30多种不同的参数解析器的实现。他们可以从请求参数将函数需要的参数解析出来。包括：url路径变量，请求体参数，请求头，cookies，session等。<br><code>returnValueHandlers</code>在<code>HandlerMethodArgumentResolver</code>实例中有不同实现。同样也有很多不同的返回值处理器来处理方法返回的结果，创建<code>ModelAndView</code>对象。<br>例如：当函数<code>hello()</code>返回一个string的时候，<code>ViewNameMethodReturnValueHandler</code>处理这个值。<code>login()</code>返回一个<code>ModelAndView</code>对象的时候，Sring使用<code>ModelAndViewMethodReturnValueHandler</code>处理这个值。</p>
<h5 id="渲染视图"><a href="#渲染视图" class="headerlink" title="渲染视图"></a>渲染视图</h5><p>现在Spring已经处理了HTTP请求，获取了<code>ModelAndView</code>实例，现在它需要在用户浏览器渲染HTML页面了。它依赖于由Model和选择的模版组成的<code>ModelAndView</code>对象。<br>同样的，Spring也可以渲染JSON ,XML或者其他HTTP协议接受的类型。这些将在接下来的REST相关了解更多。<br>现在回去看一下<code>DispatcherServlet</code>。<code>render()</code>首先使用<code>LocaleResolver</code>实例设置返回的Local。首先假设浏览器已经正确设置Accetp头。默认使用<code>AcceptHeaderLocaleResolver</code>来处理。<br>在渲染过程中，<code>ModelAndView</code>可以包含一个视图的名字或者是已经选择的视图，或者如果controller依赖于默认视图也可以没有。<br>既然<code>hello()</code>和<code>login()</code>方法制定了字符串名字作为视图名称，所以需要使用viewResolvers来查找视图。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (ViewResolver viewResolver : <span class="keyword">this</span>.viewResolvers) &#123;</div><div class="line">    View view = viewResolver.resolveViewName(viewName, locale);</div><div class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ViewResolver的实现由很多，这里使用了由<code>thymeleaf-spring5</code>提供的<code>ThymeleafViewResolver</code>实现。解析器知道去哪里查找视图，并且提供相应的视图实例。<br>调用完<code>render()</code>之后，Spring就完成了将HTML页面渲染到用户浏览器的任务。</p>
<h5 id="REST-支持"><a href="#REST-支持" class="headerlink" title="REST 支持"></a>REST 支持</h5><p>除了MVC的场景，我们可以使用狂减创建rest web service。<br>一个简单的场景，可以使用由<code>@RequestBody</code>修饰的POJO作为参数。由<code>@ResponseBody</code>修饰方法，指定方法的返回结果直接写入到响应体中。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</div><div class="line"></div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="meta">@PostMapping</span>(<span class="string">"/message"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> MyOutputResource <span class="title">sendMessage</span><span class="params">(</span></span></div><div class="line">  @RequestBody MyInputResource inputResource) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyOutputResource(<span class="string">"Received: "</span></div><div class="line">      + inputResource.getRequestMessage());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>感谢SpringMVC的扩展性，这样做也是可以的。<br>框架使用<code>HttpMessageConverter</code>将内部DTO转换成REST的表示。例如：<code>MappingJackson2HttpMessageConverter</code>的可以使用Jackson库将转换model和JSON。<br>为了简化创建REST API，Srping 引入了<code>@RestController</code>注解。默认使用<code>@ResonseBody</code>这样就不需要在每个方法中使用了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestfulWebServiceController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/message"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> MyOutputResource <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyOutputResource(<span class="string">"Hello!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>在这篇文章中，详细描述了Spring MVC处理HTTP请求的各个步骤。了解到Spring 框架是如何将各个组件组合在一起提供处理HTTP协议的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://stackify.com/spring-mvc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;  &lt;/p&gt;
&lt;h5 id=&quot;初始工程&quot;&gt;&lt;a href=&quot;#初始工程&quot; class=&quot;headerlink&quot;
    
    </summary>
    
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="SpringMVC" scheme="https://mashuai.github.io/tags/SpringMVC/"/>
    
      <category term="Spring" scheme="https://mashuai.github.io/tags/Spring/"/>
    
      <category term="Web" scheme="https://mashuai.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Date Time API</title>
    <link href="https://mashuai.github.io/2018/04/06/java8-date-time-api/"/>
    <id>https://mashuai.github.io/2018/04/06/java8-date-time-api/</id>
    <published>2018-04-05T16:39:10.000Z</published>
    <updated>2018-04-17T01:47:30.621Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.studytrails.com/java/java8/java8_date_and_time/" target="_blank" rel="external">原文地址</a>  </p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Java8 带来了处理日期和时间需要的方式。几乎所有人都有使用Java Date 痛苦的经历。有很多人因此切换到了Joda Time，但是Java8现在有了更清晰，更可扩展的API。在我们学习API钱，先了解一下日期和时间的概念。Java日期遵循<a href="http://en.wikipedia.org/wiki/Gregorian_calendar" target="_blank" rel="external">公历</a>规则。表示时间和日期的类放在<code>java.time</code>包中。在这个包里比较重要的API有：  </p>
<ul>
<li><strong>java.time.Period</strong>: 表示日期时期时间中的日期。表示日期部分的，年、月、日。例如：1年，两个月，5天。</li>
<li><strong>java.time.Duration</strong>: 表示日期时间中的时间。 表示时间的，秒，纳秒。例如：5秒。</li>
<li><strong>java.time.Instant</strong>: 表示时间线的一瞬间。保存的是UNIX时间戳的秒数，同时有另一个字段保存纳秒。</li>
<li><strong>java.time.LocalDate</strong>: 保存日期时间中的日期，用年-月-日表示。不包含时区，是不可变类。</li>
<li><strong>java.time.LocalTime</strong>: 保存日期时间中的时间，不包含时区。</li>
<li><strong>java.time.LocalDateTime</strong>: 保存LocalDate和LocalTime，不包含时区。</li>
<li><strong>java.time.ZoneDateTime</strong>: 保存LocalDateTIme，使用<code>ZoneOffset</code>保存时区信息。可以访问ZoneRule来转换本地时间。</li>
<li><strong>java.time.ZoneOffset</strong>: 保存时区相对于UTC的位移，时区信息保存在ZoneId中。</li>
<li><strong>java.time.OffsetDateTime</strong>: 通过位移来表示本地时间。这个类不包含时区规则。    </li>
</ul>
<h5 id="创建本地日期"><a href="#创建本地日期" class="headerlink" title="创建本地日期"></a>创建本地日期</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instant now = Instant.now();</div><div class="line"><span class="comment">//2014-09-20T14:32:33.646Z</span></div></pre></td></tr></table></figure>
<p>这个语句创建了一个新的时间实例。这个实例没有时区信息，如果打印这个实例将会打印UTC时间。  </p>
<h5 id="打印Unix时间戳"><a href="#打印Unix时间戳" class="headerlink" title="打印Unix时间戳"></a>打印Unix时间戳</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.Println(now.getEpochSecond());</div><div class="line"><span class="comment">// prints 1411137153</span></div></pre></td></tr></table></figure>
<p>Unix时间戳是从1970-01-01T00:00:00Z开始的。</p>
<h5 id="Instant-加时间"><a href="#Instant-加时间" class="headerlink" title="Instant 加时间"></a>Instant 加时间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instant tomorrow = now.plus(<span class="number">1</span>, ChronoUnit.DAYS);</div><div class="line"><span class="comment">// prints 2014-09-20T14:32:33.646Z</span></div></pre></td></tr></table></figure>
<p>这个函数允许添加时间间隔。时间间隔可以是：NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS。</p>
<h5 id="Instant-减时间"><a href="#Instant-减时间" class="headerlink" title="Instant 减时间"></a>Instant 减时间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Instant yesterday = now.minus(<span class="number">1</span>,ChronoUnit.HALF_DAYS);</div><div class="line"><span class="comment">// prints 2014-09-20T03:38:33.860Z</span></div></pre></td></tr></table></figure>
<p>这个minus函数允许从Instant中减时间，时间间隔同plus。</p>
<h5 id="对比两个Instant"><a href="#对比两个Instant" class="headerlink" title="对比两个Instant"></a>对比两个Instant</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(now.compareTo(tomorrow)); <span class="comment">// prints -1</span></div></pre></td></tr></table></figure>
<p>对比函数可以比较两个日期，如果参数在比较的Instant之后则返回-1，之前则返回1。</p>
<h5 id="检查Instant是否在另一个Instant之后"><a href="#检查Instant是否在另一个Instant之后" class="headerlink" title="检查Instant是否在另一个Instant之后"></a>检查Instant是否在另一个Instant之后</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(now.isAfter(yesterday));<span class="comment">// prints true</span></div></pre></td></tr></table></figure>
<h5 id="创建LocalDateTime"><a href="#创建LocalDateTime" class="headerlink" title="创建LocalDateTime"></a>创建LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDateTime localDateTime = LocalDateTime.now();</div><div class="line">System.out.println(localDateTime); <span class="comment">// prints 2014-09-28T13:01:40.556</span></div></pre></td></tr></table></figure>
<p>注意，这个得到的是本地时区的时间</p>
<h5 id="将LocalDateTime转换成其他时区时间"><a href="#将LocalDateTime转换成其他时区时间" class="headerlink" title="将LocalDateTime转换成其他时区时间"></a>将LocalDateTime转换成其他时区时间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(localDateTime.atZone(ZoneId.of(<span class="string">"America/New_York"</span>)));</div><div class="line"><span class="comment">// prints 2014-09-28T13:07:31.207-04:00[America/New_York]</span></div></pre></td></tr></table></figure>
<p>这个将会创建一个新的ZonedDateTime</p>
<h5 id="从DateTime中获取星期"><a href="#从DateTime中获取星期" class="headerlink" title="从DateTime中获取星期"></a>从DateTime中获取星期</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">System.out.println(DayOfWeek.from(localDateTime));</div><div class="line"><span class="comment">// prints SUNDAY.</span></div><div class="line"><span class="comment">// (yes, i am working on a sunday :-( ) ))</span></div></pre></td></tr></table></figure>
<h5 id="从DateTime中获取一年中第几天"><a href="#从DateTime中获取一年中第几天" class="headerlink" title="从DateTime中获取一年中第几天"></a>从DateTime中获取一年中第几天</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(localDateTime.get(ChronoField.DAY_OF_YEAR));</div><div class="line"><span class="comment">// prints 271</span></div></pre></td></tr></table></figure>
<p>其他的可以是MINUTE_OF_HOUR, MINUTE_OF_DAY, HOUR_OF_AMPM, HOUR_OF_DAY, AMPM_OF_DAY, DAY_OF_WEEK, DAY_OF_MONTH, DAY_OF_YEAR, MONTH_OF_YEAR, YEAR, OFFSET_SECONDS（UTC时间的位移）</p>
<h5 id="从LocalDateTime中获取LocalDate"><a href="#从LocalDateTime中获取LocalDate" class="headerlink" title="从LocalDateTime中获取LocalDate"></a>从LocalDateTime中获取LocalDate</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(localDateTime.toLocalDate());</div><div class="line"><span class="comment">// prints 2014-09-29</span></div></pre></td></tr></table></figure>
<h5 id="从LocalDateTIme中获取LocalTime"><a href="#从LocalDateTIme中获取LocalTime" class="headerlink" title="从LocalDateTIme中获取LocalTime"></a>从LocalDateTIme中获取LocalTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(localDateTime.toLocalTime());</div><div class="line"><span class="comment">// prints 22:26:30.146</span></div></pre></td></tr></table></figure>
<h5 id="通过年月日时分创建LocalDateTime"><a href="#通过年月日时分创建LocalDateTime" class="headerlink" title="通过年月日时分创建LocalDateTime"></a>通过年月日时分创建LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(LocalDateTime.of(<span class="number">2014</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">0</span>));</div><div class="line"><span class="comment">// prints 2014-10-01T10:00</span></div></pre></td></tr></table></figure>
<h5 id="通过解析字符串创建LocalDateTime"><a href="#通过解析字符串创建LocalDateTime" class="headerlink" title="通过解析字符串创建LocalDateTime"></a>通过解析字符串创建LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalDateTime parsedLocalDateTime = LocalDateTime.parse(<span class="string">"2014-01-01T11:00"</span>);</div></pre></td></tr></table></figure>
<h5 id="创建另一个时区的LocalDateTime"><a href="#创建另一个时区的LocalDateTime" class="headerlink" title="创建另一个时区的LocalDateTime"></a>创建另一个时区的LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(LocalDateTime.now(ZoneId.of(<span class="string">"UTC"</span>)));</div><div class="line"><span class="comment">// prints 2014-09-29T17:07:26.653 (the local timezone in UTC)</span></div></pre></td></tr></table></figure>
<h5 id="通过Instant和时区创建LocalDateTime"><a href="#通过Instant和时区创建LocalDateTime" class="headerlink" title="通过Instant和时区创建LocalDateTime"></a>通过Instant和时区创建LocalDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Instant now = Instant.now();</div><div class="line">System.out.println(LocalDateTime.ofInstant(now, ZoneId.of(<span class="string">"UTC"</span>)));</div><div class="line"><span class="comment">//2014-09-29T17:09:19.644</span></div></pre></td></tr></table></figure>
<h5 id="创建ZonedDateTime"><a href="#创建ZonedDateTime" class="headerlink" title="创建ZonedDateTime"></a>创建ZonedDateTime</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ZonedDateTime zonedDateTime = ZonedDateTime.now();</div><div class="line"><span class="comment">//2014-09-29T22:41:24.908+05:30[Asia/Calcutta]</span></div></pre></td></tr></table></figure>
<h5 id="获取两个不同时间在不同单位之差"><a href="#获取两个不同时间在不同单位之差" class="headerlink" title="获取两个不同时间在不同单位之差"></a>获取两个不同时间在不同单位之差</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(zonedDateTime.until(ZonedDateTime.parse(&quot;2014-09-29T22:41:00-10:00&quot;), ChronoUnit.HOURS));</div><div class="line">// prints the difference between the current zonedDateTime and the zonedatetime parsed from the above string</div></pre></td></tr></table></figure>
<h5 id="获取当前ZoneDateTime的位移"><a href="#获取当前ZoneDateTime的位移" class="headerlink" title="获取当前ZoneDateTime的位移"></a>获取当前ZoneDateTime的位移</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(zonedDateTime.getOffset());</div><div class="line"><span class="comment">// prints the offset e.g. +10:00</span></div></pre></td></tr></table></figure>
<h5 id="使用DateTimeFormatter解析或者格式化时间"><a href="#使用DateTimeFormatter解析或者格式化时间" class="headerlink" title="使用DateTimeFormatter解析或者格式化时间"></a>使用DateTimeFormatter解析或者格式化时间</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(zonedDateTime.format(DateTimeFormatter.ofPattern(<span class="string">"'The' dd 'day of' MMM 'in year' YYYY 'and zone is' z"</span>)));</div><div class="line"><span class="comment">// prints The 29 day of Sep in year 2014 and zone is IST</span></div></pre></td></tr></table></figure>
<h5 id="将ZoneDateTime更改时区"><a href="#将ZoneDateTime更改时区" class="headerlink" title="将ZoneDateTime更改时区"></a>将ZoneDateTime更改时区</h5><p>有两种方式可以完成这个任务，第一种不更改Instant更改时区，第二种更改时区不更改LocalTime<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(zonedDateTime);</div><div class="line">System.out.println(zonedDateTime.toInstant());</div><div class="line">System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of(<span class="string">"America/Chicago"</span>)));</div><div class="line">System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of(<span class="string">"America/Chicago"</span>)));</div><div class="line"></div><div class="line"><span class="comment">// prints </span></div><div class="line"><span class="comment">//System.out.println(zonedDateTime);</span></div><div class="line"><span class="comment">//System.out.println(zonedDateTime.toInstant());</span></div><div class="line"><span class="comment">//System.out.println(zonedDateTime.withZoneSameInstant(ZoneId.of("America/Chicago")));</span></div><div class="line"><span class="comment">//System.out.println(zonedDateTime.withZoneSameLocal(ZoneId.of("America/Chicago")));</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.studytrails.com/java/java8/java8_date_and_time/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;  &lt;/p&gt;
&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="Java8" scheme="https://mashuai.github.io/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>Jackson 简明教程</title>
    <link href="https://mashuai.github.io/2018/03/31/jackson-tutorial/"/>
    <id>https://mashuai.github.io/2018/03/31/jackson-tutorial/</id>
    <published>2018-03-30T16:39:10.000Z</published>
    <updated>2018-04-02T10:29:57.578Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/FasterXML/jackson-databind/" target="_blank" rel="external">原文地址</a>  </p>
<h4 id="一分钟教程：POJOs和JSON的互相转换"><a href="#一分钟教程：POJOs和JSON的互相转换" class="headerlink" title="一分钟教程：POJOs和JSON的互相转换"></a>一分钟教程：POJOs和JSON的互相转换</h4><p>&emsp;&emsp;最常用的功能就是将一段JSON片段组装成POJOs。所以我们首先从这个入手。下面是一个简单的，有两个属性的POJO：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Note: can use getters/setters as well; here we just use public fields directly:</div><div class="line">public class MyValue &#123;</div><div class="line">  public String name;</div><div class="line">  public int age;</div><div class="line">  // NOTE: if using getters/setters, can keep fields `protected` or `private`</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们需要一个<code>com.fasterxml.jackson.databind.ObjectMapper</code>的实例来做所有的数据绑定，<code>ObjectMapper</code>仅需要创建一次即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ObjectMapper mapper = new ObjectMapper(); // create once, reuse</div></pre></td></tr></table></figure></p>
<p>采用默认构造函数目前基本够用，当需要处理特殊情况的时候再学习如何根据情况配置ObjectMapper。以下是使用<code>ObjectMapper</code>的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MyValue value = mapper.readValue(new File(&quot;data.json&quot;), MyValue.class);</div><div class="line">// or:</div><div class="line">value = mapper.readValue(new URL(&quot;http://some.com/api/entry.json&quot;), MyValue.class);</div><div class="line">// or:</div><div class="line">value = mapper.readValue(&quot;&#123;\&quot;name\&quot;:\&quot;Bob\&quot;, \&quot;age\&quot;:13&#125;&quot;, MyValue.class);</div></pre></td></tr></table></figure></p>
<p>如果想要生成JSON，只需要反过来就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mapper.writeValue(new File(&quot;result.json&quot;), myResultObject);</div><div class="line">// or:</div><div class="line">byte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);</div><div class="line">// or:</div><div class="line">String jsonString = mapper.writeValueAsString(myResultObject);</div></pre></td></tr></table></figure></p>
<h4 id="三分钟教程：泛型集合和树模型"><a href="#三分钟教程：泛型集合和树模型" class="headerlink" title="三分钟教程：泛型集合和树模型"></a>三分钟教程：泛型集合和树模型</h4><p>除了处理Bean风格的POJO，Jackson同时可以处理JDK的<code>List</code>和<code>Map</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; scoreByName = mapper.readValue(jsonSource, Map.class);</div><div class="line">List&lt;String&gt; names = mapper.readValue(jsonSource, List.class);</div><div class="line"></div><div class="line">// and can obviously write out as well</div><div class="line">mapper.writeValue(new File(&quot;names.json&quot;), names);</div></pre></td></tr></table></figure></p>
<p>匹配这种，只要JSON的结构匹配，并且类型简单就可以。如果有POJO值，则需要声明他的实际类型(PS:POJO的属性如果是<code>List</code>等类型，则不需要指定类型)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, ResultValue&gt; results = mapper.readValue(jsonSource,</div><div class="line">   new TypeReference&lt;Map&lt;String, ResultValue&gt;&gt;() &#123; &#125; );</div><div class="line">// why extra work? Java Type Erasure will prevent type detection otherwise &#125;)</div></pre></td></tr></table></figure></p>
<p>然而，处理<code>Map</code>,<code>List</code>和其他’简单’类型(String,Number,Boolean)可以更见简单，对象遍历非常麻烦，所以Jackson的<code>Tree Model</code>迟早有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// can be read as generic JsonNode, if it can be Object or Array; or,</div><div class="line">// if known to be Object, as ObjectNode, if array, ArrayNode etc:</div><div class="line">ObjectNode root = mapper.readTree(&quot;stuff.json&quot;);</div><div class="line">String name = root.get(&quot;name&quot;).asText();</div><div class="line">int age = root.get(&quot;age&quot;).asInt();</div><div class="line"></div><div class="line">// can modify as well: this adds child Object as property &apos;other&apos;, set property &apos;type&apos;</div><div class="line">root.with(&quot;other&quot;).put(&quot;type&quot;, &quot;student&quot;);</div><div class="line">String json = mapper.writeValueAsString(root);</div><div class="line"></div><div class="line">// with above, we end up with something like as &apos;json&apos; String:</div><div class="line">// &#123;</div><div class="line">//   &quot;name&quot; : &quot;Bob&quot;, &quot;age&quot; : 13,</div><div class="line">//   &quot;other&quot; : &#123;</div><div class="line">//      &quot;type&quot; : &quot;student&quot;</div><div class="line">//   &#125;</div><div class="line">// &#125;</div></pre></td></tr></table></figure></p>
<p>树模型比data-bind更加的方便，尤其是高度动态的数据结构，或者JSON无法完美映射Java类的时候。</p>
<h4 id="五分钟教程：Streaming-parser-generator"><a href="#五分钟教程：Streaming-parser-generator" class="headerlink" title="五分钟教程：Streaming parser, generator"></a>五分钟教程：Streaming parser, generator</h4><p>有一种更见标准的处理模型，叫做incremental model，也叫Stream model ，这种处理方法和data-bind方式同样方便，和Tree Model同样灵活。data-bind和Tree Model 底层都是基于它。但是同样也暴露给那些想要极致性能和完全掌控解析JSON的用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">JsonFactory f = mapper.getFactory(); // may alternatively construct directly too</div><div class="line"></div><div class="line">// First: write simple JSON output</div><div class="line">File jsonFile = new File(&quot;test.json&quot;);</div><div class="line">JsonGenerator g = f.createGenerator(jsonFile);</div><div class="line">// write JSON: &#123; &quot;message&quot; : &quot;Hello world!&quot; &#125;</div><div class="line">g.writeStartObject();</div><div class="line">g.writeStringField(&quot;message&quot;, &quot;Hello world!&quot;);</div><div class="line">g.writeEndObject();</div><div class="line">g.close();</div><div class="line"></div><div class="line">// Second: read file back</div><div class="line">JsonParser p = f.createParser(jsonFile);</div><div class="line"></div><div class="line">JsonToken t = p.nextToken(); // Should be JsonToken.START_OBJECT</div><div class="line">t = p.nextToken(); // JsonToken.FIELD_NAME</div><div class="line">if ((t != JsonToken.FIELD_NAME) || !&quot;message&quot;.equals(p.getCurrentName())) &#123;</div><div class="line">   // handle error</div><div class="line">&#125;</div><div class="line">t = p.nextToken();</div><div class="line">if (t != JsonToken.VALUE_STRING) &#123;</div><div class="line">   // similarly</div><div class="line">&#125;</div><div class="line">String msg = p.getText();</div><div class="line">System.out.printf(&quot;My message to you is: %s!\n&quot;, msg);</div><div class="line">p.close(); &#125;</div></pre></td></tr></table></figure></p>
<h4 id="10分钟教程：配置"><a href="#10分钟教程：配置" class="headerlink" title="10分钟教程：配置"></a>10分钟教程：配置</h4><p>有两种入门的配置方法：feature 和 Annotation</p>
<h5 id="feature-配置"><a href="#feature-配置" class="headerlink" title="feature 配置"></a>feature 配置</h5><p>下面是一些最常用的配置<br>首先从高层的data-bind配置开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// SerializationFeature for changing how JSON is written</div><div class="line"></div><div class="line">// to enable standard indentation (&quot;pretty-printing&quot;):</div><div class="line">mapper.enable(SerializationFeature.INDENT_OUTPUT);</div><div class="line">// to allow serialization of &quot;empty&quot; POJOs (no properties to serialize)</div><div class="line">// (without this setting, an exception is thrown in those cases)</div><div class="line">mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);</div><div class="line">// to write java.util.Date, Calendar as number (timestamp):</div><div class="line">mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</div><div class="line"></div><div class="line">// DeserializationFeature for changing how JSON is read as POJOs:</div><div class="line"></div><div class="line">// to prevent exception when encountering unknown property:</div><div class="line">mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</div><div class="line">// to allow coercion of JSON empty String (&quot;&quot;) to null Object value:</div><div class="line">mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</div></pre></td></tr></table></figure></p>
<p>下面是一些可以控制JSON底层解析，生成的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// JsonParser.Feature for configuring parsing settings:</div><div class="line"></div><div class="line">// to allow C/C++ style comments in JSON (non-standard, disabled by default)</div><div class="line">// (note: with Jackson 2.5, there is also `mapper.enable(feature)` / `mapper.disable(feature)`)</div><div class="line">mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);</div><div class="line">// to allow (non-standard) unquoted field names in JSON:</div><div class="line">mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);</div><div class="line">// to allow use of apostrophes (single quotes), non standard</div><div class="line">mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);</div><div class="line"></div><div class="line">// JsonGenerator.Feature for configuring low-level JSON generation:</div><div class="line"></div><div class="line">// to force escaping of non-ASCII characters:</div><div class="line">mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);</div></pre></td></tr></table></figure></p>
<h5 id="注解配置：修改属性名"><a href="#注解配置：修改属性名" class="headerlink" title="注解配置：修改属性名"></a>注解配置：修改属性名</h5><p>最简单的使用注解配置的方式是使用<code>@JsonProperty</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyBean &#123;</div><div class="line">   private String _name;</div><div class="line"></div><div class="line">   // without annotation, we&apos;d get &quot;theName&quot;, but we want &quot;name&quot;:</div><div class="line">   @JsonProperty(&quot;name&quot;)</div><div class="line">   public String getTheName() &#123; return _name; &#125;</div><div class="line"></div><div class="line">   // note: it is enough to add annotation on just getter OR setter;</div><div class="line">   // so we can omit it here</div><div class="line">   public void setTheName(String n) &#123; _name = n; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="注解配置：忽略属性"><a href="#注解配置：忽略属性" class="headerlink" title="注解配置：忽略属性"></a>注解配置：忽略属性</h5><p>有两个可以设置忽略属性的注解，一个是<code>@JsonIgnore</code> 修饰的是单个属性，一个是<code>@JsonIgnoreProperties</code> 修饰的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// means that if we see &quot;foo&quot; or &quot;bar&quot; in JSON, they will be quietly skipped</div><div class="line">// regardless of whether POJO has such properties</div><div class="line">@JsonIgnoreProperties(&#123; &quot;foo&quot;, &quot;bar&quot; &#125;)</div><div class="line">public class MyBean</div><div class="line">&#123;</div><div class="line">   // will not be written as JSON; nor assigned from JSON:</div><div class="line">   @JsonIgnore</div><div class="line">   public String internal;</div><div class="line"></div><div class="line">   // no annotation, public field is read/written normally</div><div class="line">   public String external;</div><div class="line"></div><div class="line">   @JsonIgnore</div><div class="line">   public void setCode(int c) &#123; _code = c; &#125;</div><div class="line"></div><div class="line">   // note: will also be ignored because setter has annotation!</div><div class="line">   public int getCode() &#123; return _code; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于重命名，所以注解是在匹配的的字段，get，set中共享的：如果其中一个设置了<code>@JsonIgnore</code>，其他的也受影响。当然也可以使用分离的注解来解决问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class ReadButDontWriteProps &#123;</div><div class="line">   private String _name;</div><div class="line">   @JsonProperty public void setName(String n) &#123; _name = n; &#125;</div><div class="line">   @JsonIgnore public String getName() &#123; return _name; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，<code>name</code>不会被写入到JSON中，但是如果JSON中有，则会映射到Java对象中。</p>
<h5 id="注解配置：定制注解构造器"><a href="#注解配置：定制注解构造器" class="headerlink" title="注解配置：定制注解构造器"></a>注解配置：定制注解构造器</h5><p>和其他的data-bind包不同，jackson 不需要定义默认的构造函数（即不包含参数的构造函数）。如果需要，可以定义一个简单的包含参数的构造函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class CtorBean</div><div class="line">&#123;</div><div class="line">  public final String name;</div><div class="line">  public final int age;</div><div class="line"></div><div class="line">  @JsonCreator // constructor can be public, private, whatever</div><div class="line">  private CtorBean(@JsonProperty(&quot;name&quot;) String name,</div><div class="line">    @JsonProperty(&quot;age&quot;) int age)</div><div class="line">  &#123;</div><div class="line">      this.name = name;</div><div class="line">      this.age = age;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造函数在不可变对象中非常实用。<br>也可以直接定义一个工厂方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class FactoryBean</div><div class="line">&#123;</div><div class="line">    // fields etc omitted for brewity</div><div class="line"></div><div class="line">    @JsonCreator</div><div class="line">    public static FactoryBean create(@JsonProperty(&quot;name&quot;) String name) &#123;</div><div class="line">      // construct and return an instance</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="其他特性："><a href="#其他特性：" class="headerlink" title="其他特性："></a>其他特性：</h4><p>一个有用，但是不被广泛知晓的功能就是Jackson可以任意转换两个POJO。可以将其想象成两步，第一步，将POJO写成JSON，第二步讲JSON写成另一个POJO。实现的时候用了更加高效的一种方法，并没有生成中间的JSON。<br>转换在兼容的类型中运行的很好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ResultType result = mapper.convertValue(sourceObject, ResultType.class);</div></pre></td></tr></table></figure></p>
<p>只要这两个POJO的类型兼容，即to json 和 from json的成功，那么就可以成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Convert from List&lt;Integer&gt; to int[]</div><div class="line">List&lt;Integer&gt; sourceList = ...;</div><div class="line">int[] ints = mapper.convertValue(sourceList, int[].class);</div><div class="line">// Convert a POJO into Map!</div><div class="line">Map&lt;String,Object&gt; propertyMap = mapper.convertValue(pojoValue, Map.class);</div><div class="line">// ... and back</div><div class="line">PojoType pojo = mapper.convertValue(propertyMap, PojoType.class);</div><div class="line">// decode Base64! (default byte[] representation is base64-encoded String)</div><div class="line">String base64 = &quot;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz&quot;;</div><div class="line">byte[] binary = mapper.convertValue(base64, byte[].class);</div></pre></td></tr></table></figure></p>
<p>基本上Jackson可以替换很多Apache Commons的组件，例如Base64的编码解码，处理动态POJO等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/FasterXML/jackson-databind/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;  &lt;/p&gt;
&lt;h4 id=&quot;一分钟教程：POJOs和JSON的互相转换&quot;&gt;&lt;a 
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="JSON" scheme="https://mashuai.github.io/tags/JSON/"/>
    
      <category term="Jackson" scheme="https://mashuai.github.io/tags/Jackson/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 配置</title>
    <link href="https://mashuai.github.io/2017/06/28/mybaits-configuration/"/>
    <id>https://mashuai.github.io/2017/06/28/mybaits-configuration/</id>
    <published>2017-06-28T06:13:32.000Z</published>
    <updated>2017-06-28T06:43:55.679Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.mybatis.org/mybatis-3/configuration.html" target="_blank" rel="external">原文链接</a></p>
<p>MyBatis的配置包含了设置和属性，他们对MyBatis的行为有很大的影响。MyBatis的配置文件层次结构如下：</p>
<ul>
<li>configuration<ul>
<li>properties</li>
<li>settings</li>
<li>typeAliases</li>
<li>typeHandlers</li>
<li>objectFactory</li>
<li>plugins</li>
<li>environments<ul>
<li>environment<ul>
<li>transactionManager</li>
<li>dataSource</li>
</ul>
</li>
</ul>
</li>
<li>databaseIdProvider</li>
<li>mappers</li>
</ul>
</li>
</ul>
<h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>可以通过一个典型的Java Properties 类实例配置可替换的外部属性，也可以通过子元素传递这些配置属性，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</div><div class="line">  &lt;property name=&quot;username&quot; value=&quot;dev_user&quot;/&gt;</div><div class="line">  &lt;property name=&quot;password&quot; value=&quot;F2Fa3!33TYyg&quot;/&gt;</div><div class="line">&lt;/properties&gt;</div></pre></td></tr></table></figure></p>
<p>然后这些配置属性就可以应用于配置文件中需要动态配置的其他属性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</div><div class="line">  &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</div><div class="line">  &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</div><div class="line">  &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</div><div class="line">  &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</div><div class="line">&lt;/dataSource&gt;</div></pre></td></tr></table></figure></p>
<p>在这个例子中的username和password将会被properties的配置属性替换。driver和url属性会被config.properties的配置替换。这个为配置提供了很多的选项。<br>Properties同样可以直传入SqlSessionFactoryBuild.build() 方法中，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);</div><div class="line"></div><div class="line">// ... or ...</div><div class="line"></div><div class="line">SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, props);</div></pre></td></tr></table></figure></p>
<p>如果同一个属性同时配置到不同的位置，MyBatis按照如下的顺序加载它们：    </p>
<ol>
<li>在Properties内的子元素首先被加载。     </li>
<li>其次从resource classpath和url中加载属性并覆盖已存在的属性。    </li>
<li>作为方法参数的属性最后被加载，并且覆盖前面两次相同的属性。</li>
</ol>
<p>因此，优先级最高的是直接作为参数传入方法，其次是从resource classpath或者url加载的配置文件，最后是Properties中的子元素定义的属性。<br>MyBatis 3.4.2 之后可以如下使用默认占位符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</div><div class="line">  &lt;!-- ... --&gt;</div><div class="line">  &lt;property name=&quot;username&quot; value=&quot;$&#123;username:ut_user&#125;&quot;/&gt; &lt;!-- If &apos;username&apos; property not present, username become &apos;ut_user&apos; --&gt;</div><div class="line">&lt;/dataSource&gt;</div></pre></td></tr></table></figure></p>
<p>这个功能默认是无效的，如果要开启这个功能，需要在配置属性中如下开启：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</div><div class="line">  &lt;!-- ... --&gt;</div><div class="line">  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot; value=&quot;true&quot;/&gt; &lt;!-- Enable this feature --&gt;</div><div class="line">&lt;/properties&gt;</div></pre></td></tr></table></figure></p>
<p>注意：如果已经使用了“：”作为属性的键例如：<code>db:username</code>，或者是在sql的定义中使用了OGNL的三元符，例如：<code>${tableName != null ? tableName : &#39;global_constants&#39;}</code>那么就需要修改默认的分隔符，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;properties resource=&quot;org/mybatis/example/config.properties&quot;&gt;</div><div class="line">  &lt;!-- ... --&gt;</div><div class="line">  &lt;property name=&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot; value=&quot;?:&quot;/&gt; &lt;!-- Change default value of separator --&gt;</div><div class="line">&lt;/properties&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;dataSource type=&quot;POOLED&quot;&gt;</div><div class="line">  &lt;!-- ... --&gt;</div><div class="line">  &lt;property name=&quot;username&quot; value=&quot;$&#123;db:username?:ut_user&#125;&quot;/&gt;</div><div class="line">&lt;/dataSource&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.mybatis.org/mybatis-3/configuration.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MyBatis的配置包含了设置和属性，他们对MyBati
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="Mybatis" scheme="https://mashuai.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Linux 如何查找Java 程序CPU负载过高</title>
    <link href="https://mashuai.github.io/2017/03/25/cup-load-high/"/>
    <id>https://mashuai.github.io/2017/03/25/cup-load-high/</id>
    <published>2017-03-25T03:20:26.000Z</published>
    <updated>2017-03-28T02:39:09.249Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;准备程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package test;</div><div class="line"></div><div class="line">public class Test&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        new Thread(new Runnable()&#123;</div><div class="line">            public void run()&#123;</div><div class="line">                while(true)&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其中一个线程回导致一直占用CPU，编译运行。通过<code>top</code> 获取CPU占用信息<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/top.png" alt="top cpu"><br>可以看到占用最高的 pid是 25955<br>通过<code>top -p 25955 -H</code> 获取进程内部线程的CPU使用率。<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/tophp.png" alt="topph"><br>可以发现占用最高的线程ID是 <code>25965</code> 将其转换为16进制<code>python -c &#39;print hex(25965)&#39;</code> 得到的值是<code>0x656d</code><br>使用 <code>jstack -l 25955 &gt; jstack.log</code> 得到Java进程的Thread dump，通过 <code>grep -i 0x656d -A 30 jstack.log</code> 获取Java Thread id为0x656d的线程的thread dump。<br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/images/jstack.png" alt="jstack"><br>然后就可以定位相应代码查找代码占用CPU过高问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;准备程序：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div
    
    </summary>
    
    
      <category term="CPU" scheme="https://mashuai.github.io/tags/CPU/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="Linux" scheme="https://mashuai.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git - 分支管理</title>
    <link href="https://mashuai.github.io/2017/03/24/Git%E5%88%86%E6%94%AF/"/>
    <id>https://mashuai.github.io/2017/03/24/Git分支/</id>
    <published>2017-03-24T03:32:02.000Z</published>
    <updated>2017-03-27T11:34:00.898Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分支概要-Nutshell"><a href="#分支概要-Nutshell" class="headerlink" title="分支概要(Nutshell)"></a>分支概要(Nutshell)</h3><p>&emsp;&emsp; 几乎每个版本管理系统（<em>VCS</em>）都对分支有一些支持。分支就是从开发的主线分开，在其他地方继续开发，这样不至于和主线的开发产生混乱。在大多的VCS工具里，分支管理是一个复杂的流程，经常需要你为源代码目录创建一份拷贝，对于一些大型项目这会花费大量时间。</p>
<p>&emsp;&emsp; 真正理解分支首先需要明白<strong>Git</strong>是如何存储数据的：<strong>Git</strong>不会储存不同的或变化的点，而是保存一个快照（snapshot）。</p>
<p>&emsp;&emsp; 当你提交一个commit，<strong>Git</strong>会存储一个commit对象，这个对象包含：</p>
<ul>
<li>指向当前内容的快照的引用（pointer）</li>
<li>作者的姓名、邮件地址和提交的信息</li>
<li>指向上一次提交的commit的引用 （如果上一次操作是多个分支的merge操作，那么会储存多个指向不同的commit的引用；如果当前提交是首次commit，因为没有上一次commit，所以不会存储任何指向上一次commit的引用；正常的commit，会储存一个指向上次commit的引用）</li>
</ul>
<p>&emsp;&emsp; 视觉化地理解这个流程就是：假设你有一个包含三个文件的目录，添加（add操作）这三个文件后commit。添加文件时会为每个文件生成一个校验码(SHA-1 hash)，在<strong>Git</strong>的仓库(<em>repo</em>)存储文件的版本，同时添加校验码到添加的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README test.rb LICENSE</div><div class="line">$ git commit -m &apos;The initial commit of my project&apos;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 当你执行<code>git commit</code>后提交这个commit，<strong>Git</strong>会校验和每个子目录（在这个case里，只有项目的根目录），同时在<strong>Git repo</strong>里存储这些树对象。Git之后会创建一个commit对象，这个对象包含元数据和一个指向根项目树的引用 – 可以再次创建项目快照。</p>
<p>&emsp;&emsp; 你的<strong>Git repo</strong>现在包含5个对象：</p>
<ul>
<li>对应3个文件内容的3个二进制对象</li>
<li>一个树对象，呈现目录的内容和详细说明文件名和二进制对象的对应关系</li>
<li>一个commit对象，包含指向根树的引用，和commit对象的所有元数据</li>
</ul>
<p>&emsp;&emsp; 如下图所示：</p>
<p><img src="https://git-scm.com/book/en/v2/images/commit-and-tree.png" alt="Interceptors"></p>
<p>&emsp;&emsp; 如果文件做了变动，再次提交，这次提交会存储一个指向上一次提交的引用</p>
<p><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt="Interceptors"></p>
<p>&emsp;&emsp; <strong>Git</strong>的分支就是一个的简单的、轻量的、可移动的、指向这些个commit的引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分支概要-Nutshell&quot;&gt;&lt;a href=&quot;#分支概要-Nutshell&quot; class=&quot;headerlink&quot; title=&quot;分支概要(Nutshell)&quot;&gt;&lt;/a&gt;分支概要(Nutshell)&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp; 几乎每个版本管理系统（
    
    </summary>
    
    
      <category term="Git" scheme="https://mashuai.github.io/tags/Git/"/>
    
      <category term="Git分支" scheme="https://mashuai.github.io/tags/Git%E5%88%86%E6%94%AF/"/>
    
  </entry>
  
  <entry>
    <title>OKHttp https</title>
    <link href="https://mashuai.github.io/2017/03/23/okhttp/https/"/>
    <id>https://mashuai.github.io/2017/03/23/okhttp/https/</id>
    <published>2017-03-23T05:32:29.000Z</published>
    <updated>2017-03-24T03:21:06.334Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/square/okhttp/wiki/HTTPS" target="_blank" rel="external">原文链接</a></p>
<p>&emsp;&emsp;OKHttp尝试平衡两个相互矛盾的内容：</p>
<ul>
<li>连接尽可能多的主机。包括使用<a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="external">boringssl</a>的高级的主机和一些使用<a href="https://www.openssl.org/" target="_blank" rel="external">openssl</a>的过时的主机。</li>
<li>连接的安全性。包括验证远程主机的证书，通过强密码进行数据交换。</li>
</ul>
<p>&emsp;&emsp;协商连接到HTTPS的时候，OKHttp需要知道需要提供的<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/TlsVersion.html" target="_blank" rel="external">TLS版本</a>和<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/CipherSuite.html" target="_blank" rel="external">密码套件</a>。如果一个客户端需要最大化链接就需要包含过时的TLS版本和弱设计的密码组合。一个严格的客户端想要最大化安全就需要只包含最新的TLS版本和强密码套件。<br>&emsp;&emsp;安全和连接规范具体是由<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionSpec.html" target="_blank" rel="external">ConnectionSpec</a>实现的。OKHttp包含三个内置的规范：</p>
<ul>
<li><code>MODERN_TLS</code> 是连接现代HTTPS服务器的配置。</li>
<li><code>COMPATIBLE_TLS</code> 是连接非现代，但安全的HTTPS服务器的配置。</li>
<li><code>CLEARTEXT</code> 是非安全的http的配置。</li>
</ul>
<p>&emsp;&emsp;默认OKHttp会尝试使用<code>MODERN_TLS</code>连接，如果现代配置失败，回到使用<code>COMPATIBLE_TLS</code>配置。<br>&emsp;&emsp;TLS版本和密码套件在任一一个发布版本的人一个规范中都可能改变。例如，在OKHttp2.2，因为<a href="http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html" target="_blank" rel="external">POODLE</a>攻击就移除了SSL 3.0的支持。在OKHttp 3.0，移除了<a href="http://en.wikipedia.org/wiki/RC4#Security" target="_blank" rel="external">RC4</a>的支持。同桌面浏览器一样，使用罪行的OKHttp版本可以获得最好的安全保障。<br>&emsp;&emsp;也可以根据一组定制的TLS 版本和密码套件构建自己的规范。例如，下面这个配置要求使用三组高强度的密码套件。它的缺点就是必须是Android5.0+或者是最新的浏览器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ConnectionSpec spec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)  </div><div class="line">    .tlsVersions(TlsVersion.TLS_1_2)</div><div class="line">    .cipherSuites(</div><div class="line">          CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</div><div class="line">          CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</div><div class="line">          CipherSuite.TLS_DHE_RSA_WITH_AES_128_GCM_SHA256)</div><div class="line">    .build();</div><div class="line"></div><div class="line">OkHttpClient client = new OkHttpClient.Builder() </div><div class="line">    .connectionSpecs(Collections.singletonList(spec))</div><div class="line">    .build();</div></pre></td></tr></table></figure></p>
<h4 id="证书锁定"><a href="#证书锁定" class="headerlink" title="证书锁定"></a>证书锁定</h4><p>&emsp;&emsp;默认情况下OKHttp信任主机平台的证书颁发机构。这个策略可以最大化连接，但是也有可能收到权威证书攻击，例如<a href="http://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html" target="_blank" rel="external">2011 DigiNotar attack</a>。同样也假设你的证书是权威机构颁发的。<br>&emsp;&emsp;使用<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/CertificatePinner.html" target="_blank" rel="external">CertificatePinner</a>限制了哪些证书和证书颁发机构值得信任。使用证书锁定可以提高安全性，但是限制了服务端团队升级他们的TLS证书。<strong>在没的到服务端团队的许可的时候不要使用证书锁定</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public CertificatePinning() &#123;</div><div class="line">  client = new OkHttpClient.Builder()</div><div class="line">      .certificatePinner(new CertificatePinner.Builder()</div><div class="line">          .add(&quot;publicobject.com&quot;, &quot;sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=&quot;)</div><div class="line">          .build())</div><div class="line">      .build();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">  Request request = new Request.Builder()</div><div class="line">      .url(&quot;https://publicobject.com/robots.txt&quot;)</div><div class="line">      .build();</div><div class="line"></div><div class="line">  Response response = client.newCall(request).execute();</div><div class="line">  if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</div><div class="line"></div><div class="line">  for (Certificate certificate : response.handshake().peerCertificates()) &#123;</div><div class="line">    System.out.println(CertificatePinner.pin(certificate));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="定制信任证书"><a href="#定制信任证书" class="headerlink" title="定制信任证书"></a>定制信任证书</h4><p>&emsp;&emsp;下面所有的代码展示了如何使用你自己的配置代替服务端的证书配置。正如上述所言，<em>*在没的到服务端团队的许可的时候不要使用定制证书</em>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client;</div><div class="line"></div><div class="line">public CustomTrust() &#123;</div><div class="line">  SSLContext sslContext = sslContextForTrustedCertificates(trustedCertificatesInputStream());</div><div class="line">  client = new OkHttpClient.Builder()</div><div class="line">      .sslSocketFactory(sslContext.getSocketFactory())</div><div class="line">      .build();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">  Request request = new Request.Builder()</div><div class="line">      .url(&quot;https://publicobject.com/helloworld.txt&quot;)</div><div class="line">      .build();</div><div class="line"></div><div class="line">  Response response = client.newCall(request).execute();</div><div class="line">  System.out.println(response.body().string());</div><div class="line">&#125;</div><div class="line"></div><div class="line">private InputStream trustedCertificatesInputStream() &#123;</div><div class="line">  ... // Full source omitted. See sample.</div><div class="line">&#125;</div><div class="line"></div><div class="line">public SSLContext sslContextForTrustedCertificates(InputStream in) &#123;</div><div class="line">  ... // Full source omitted. See sample.</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/square/okhttp/wiki/HTTPS&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;OKHttp尝试平衡两个相互矛盾的内容：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="HTTP" scheme="https://mashuai.github.io/tags/HTTP/"/>
    
      <category term="OKHttp" scheme="https://mashuai.github.io/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>mybatis 入门</title>
    <link href="https://mashuai.github.io/2017/03/21/mybatis/mybatis-started/"/>
    <id>https://mashuai.github.io/2017/03/21/mybatis/mybatis-started/</id>
    <published>2017-03-21T03:58:14.000Z</published>
    <updated>2017-03-21T06:17:08.756Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.mybatis.org/mybatis-3/getting-started.html" target="_blank" rel="external">原文链接</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>&emsp;&emsp;使用Mybatis只需要将<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="external">mybatis-x.x.x.jar</a>添加到类路径即可。<br>&emsp;&emsp;如果使用maven只需要将下列代码添加到pom.xml中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;x.x.x&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h4 id="根据XML配置构建SqlSessionFactory"><a href="#根据XML配置构建SqlSessionFactory" class="headerlink" title="根据XML配置构建SqlSessionFactory"></a>根据XML配置构建SqlSessionFactory</h4><p>&emsp;&emsp;每一个Mybatis应用都围绕SqlSessionFactory展开。一个SqlSessionFactory实例由SqlSessionFactoryBuilder创建。SqlSessionFacotryBuilder可以通过XML的配置文件或者一个配置好的Configuration类来创建SqlSessionFactory。<br>&emsp;&emsp;根据XML配置来构建SqlSessionFacotry非常的简单。推荐使用在类路径来配置，但是同样可以使用任何的InputStream实例，包括一个普通的文件路径或者是file:// 的URL。Mybatis有一个叫<code>Resource</code>的工具函数，可以很容易的从类路径或者其他文件路径加载资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String resource = &quot;org/mybatis/example/mybatis-config.xml&quot;;</div><div class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</div><div class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;XML配置文件包含了Mybatis的核心设置，包括对应数据库连接的数据源，同样还有一个事务管理器来决定事务的范围和控制。完整的XML配置稍后会在文档中列出，下面是一个示例配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</div><div class="line">&lt;!DOCTYPE configuration</div><div class="line">  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</div><div class="line">  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</div><div class="line">&lt;configuration&gt;</div><div class="line">  &lt;environments default=&quot;development&quot;&gt;</div><div class="line">    &lt;environment id=&quot;development&quot;&gt;</div><div class="line">      &lt;transactionManager type=&quot;JDBC&quot;/&gt;</div><div class="line">      &lt;dataSource type=&quot;POOLED&quot;&gt;</div><div class="line">        &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</div><div class="line">        &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</div><div class="line">        &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;</div><div class="line">        &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</div><div class="line">      &lt;/dataSource&gt;</div><div class="line">    &lt;/environment&gt;</div><div class="line">  &lt;/environments&gt;</div><div class="line">  &lt;mappers&gt;</div><div class="line">    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;</div><div class="line">  &lt;/mappers&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;XML配置文件的元素还有很多，上面这个配置只是指出了最重要的一部分。注意XML的header，是用来验证xml文件的。<code>environment</code>元素包含了一个事务管理器和一个连接池。<code>mappers</code>元素包含了很多<code>mapper</code>，mapper可以是xml配置或者只Java 的interface，他们都包含了SQL代码和mapper的定义。</p>
<h4 id="不使用XML构建SqlSessionFactory"><a href="#不使用XML构建SqlSessionFactory" class="headerlink" title="不使用XML构建SqlSessionFactory"></a>不使用XML构建SqlSessionFactory</h4><p>&emsp;&emsp;如果你不想使用XML配置或者想自己创建配置构造器，可以直接使用Java来构建配置。MyBatis提供了一个Configuration类可以提供所有XML配置文件所能提供的配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</div><div class="line">TransactionFactory transactionFactory = new JdbcTransactionFactory();</div><div class="line">Environment environment = new Environment(&quot;development&quot;, transactionFactory, dataSource);</div><div class="line">Configuration configuration = new Configuration(environment);</div><div class="line">configuration.addMapper(BlogMapper.class);</div><div class="line">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;注意在这个配置中添加了一个mapper类。mapper类包含了一个SQL映射的注解，这样可以避免使用XML配置mapper。但是由于Java注解的限制和一些MyBatis复杂的mapper配置，XML mapper仍然是一些复杂的高级映射的首选（例如，inner join)。因此MyBatis会自动寻找并加载每一个XML配置（在这个例子中BlogMapper.xml将会被从类路径中加载)。更多的稍后介绍。</p>
<h4 id="从SqlSessionFactory获取SqlSession"><a href="#从SqlSessionFactory获取SqlSession" class="headerlink" title="从SqlSessionFactory获取SqlSession"></a>从SqlSessionFactory获取SqlSession</h4><p>&emsp;&emsp; 现在你已经有了SqlSessionFactory了，根据名字的提示，可以从它得到一个SqlSession实例。SqlSession包含了所有执行数据库操作的SQL方法。你可以直接通过SqlSession执行映射的SQL。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SqlSession session = sqlSessionFactory.openSession();</div><div class="line">try &#123;</div><div class="line">  Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);</div><div class="line">&#125; finally &#123;</div><div class="line">  session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;虽然这种方式对于之前的MyBatis的用户来说很熟悉，但是现在有一种跟清晰的方式。使用接口（例如：BlogMapper.class），该接口的方法定义了参数和返回值，这样就可以使用更加清晰的，类型安全的代码，而不再需要容易发生错误的并且去要强制类型转换的代码。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SqlSession session = sqlSessionFactory.openSession();</div><div class="line">try &#123;</div><div class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</div><div class="line">  Blog blog = mapper.selectBlog(101);</div><div class="line">&#125; finally &#123;</div><div class="line">  session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;现在让我们来看一下到底执行了些什么。</p>
<h4 id="探索映射的SQL语句"><a href="#探索映射的SQL语句" class="headerlink" title="探索映射的SQL语句"></a>探索映射的SQL语句</h4><p>&emsp;&emsp;现在你可能在想SqlSession和Mapper类到底执行了什么。映射SQL语句这个主题比较大，这个主题差不多占据了此文档的一大部分。但是下面这些语句会展示这些示例到底执行了些什么。<br>&emsp;&emsp;无论是上面还是下面这些例子，这些语句都可以被定义在XML或者注解上。让我们先使用XML类配置。通过XML映射实现的MyBatis全套功能使得MyBatis流行了很多年。如果你以前用过MyBatis，这些概念你可能很熟悉，但是也有为数众多的对XML映射文档的改进。下面是一个可以满足上面的SqlSesion调用的XML配置的映射语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</div><div class="line">&lt;!DOCTYPE mapper</div><div class="line">  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</div><div class="line">  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</div><div class="line">&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;</div><div class="line">  &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;</div><div class="line">    select * from Blog where id = #&#123;id&#125;</div><div class="line">  &lt;/select&gt;</div><div class="line">&lt;/mapper&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;虽然这个例子对于这个简单的项目看起来很重量级，实际上他是很轻量级的。你可以在一个XML的映射文件中定义许多的映射语句，因此你可以减少很多的XML的header和doctype声明。文件余下的部分完全可以自解释。在命名空间<code>org.mybatis.example.BlogMapper</code>中定义了一个名为<code>selectBlog</code>的映射语句。他可以让你像例子中那样通过全限定名<code>org.mybatis.example.BlogMapper.selectBlog</code>调用他。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Blog blog = session.selectOne(&quot;org.mybatis.example.BlogMapper.selectBlog&quot;, 101);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;注意他和调用的Java函数很相似，这么做是有原因的。这个名字可以直接映射具有相同名字的命名空间，函数名，参数，返回值都可以和select语句匹配。这样就可以通过简单的调用Mapper接口的函数来使用映射的SQL语句了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</div><div class="line">Blog blog = mapper.selectBlog(101);</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;第二个例子有很多优势，首先他并不依赖于字符串字面量，这样他更加的安全。其次，IDE都有代码补全，当导航到映射一句的时候可以利用这个。</p>
<blockquote>
<p>namespace 的注意事项<br>MyBatis之前的版本<strong>Namespace</strong>是可选的，这样既没用又困惑。现在namespace是必须的，通过一个很长的，全限定名的语句来区分不同的语句。<br>正如所见，namespace绑定了接口，即使你现在不使用他们，也要遵守这个规则，以防哪天改变想法。从长远来看，使用Namespace将他放在一个Java的package名中可以使代码更清晰，提高可用性。<br>名字解析：为了减少输入，对于所有的命名配置，包括语句，result map， cache，使用下列名字解析规则：</p>
<ul>
<li>全限定名（例如：com.mypackage.MyMapper.selectAllThings）直接查找，找到后直接使用。</li>
<li>短名字（例如：selectAllThings）可以使用任何明确的条目。然而如果匹配了多了个（例如：com.foo.selectAllThings and com.bar.selectAllThing），那么将会报名字模糊的错误，这个时候必须使用全限定名。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;对于BlogMapper还有一个小诀窍。他们的映射语句完全不需要XML配置文件，可以使用注解来代替。例如下面这个例子就可以代替XML配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package org.mybatis.example;</div><div class="line">public interface BlogMapper &#123;</div><div class="line">  @Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</div><div class="line">  Blog selectBlog(int id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;注解相对来说更加的简洁，但是由于注解自身的限制和一些复杂语句的复杂性，如果使用复杂的SQL语句最好还是使用XML配置。<br>&emsp;&emsp;这个完全取决于你和你的团队和定义映射语句的一致性类决定使用哪个方式。也就是说你不需要仅仅选择一个。从注解到XML的迁移是很方便的，反之亦然。</p>
<h4 id="作用域和生命周期"><a href="#作用域和生命周期" class="headerlink" title="作用域和生命周期"></a>作用域和生命周期</h4><p>&emsp;&emsp;明白我们现在所讨论的类的作用域和生命周期是很重要的。错误的使用会导致并发错误。</p>
<blockquote>
<p><strong>对象生命周期和依赖注入框架</strong><br>依赖注入框架可以创建线程安全的，带事务管理的SqlSession和mapper并且将它们注入到需要的Bean中，因此你可以直接忽略他的生命周期。如果要熟悉MyBatis和DI 框架的关系可以看一下MyBatis-Spring 和MyBatis-Guice两个项目</p>
</blockquote>
<h5 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h5><p>&emsp;&emsp;这个类被初始化，使用完之后可以直接丢弃了。当你创建完SqlSessionFactory之后就没必要留着他了。因此SqlSessionFactoryBuilder最好的作用域是在方法作用域中（例如一个本地变量）。可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要保留它，保证所有的XML都被解析用来做更重要的事情。</p>
<h5 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h5><p>&emsp;&emsp;当SqlSesslionFactory创建了之后，就应该一直存在你的应用中。一般来说是没有理由重新创建或处理他的。在程序运行的时候最好不要多次重新构建SqlSessionFactory。如果这样做就会有坏代码的味道了。因此SqlSessionFactory的作用域最好是应用作用域。实现的方法有很多，最好的方法就是使用单例模式或者是静态单例模式。</p>
<h5 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h5><p>&emsp;&emsp;每个线程都应该有自己的SqlSession。SqlSession的示例不能分享且非线程安全。因此最好的作用域是请求作用域和方法作用域。永远不要在静态域或者类实例中引用SqlSession。永远不要将SqlSession放到managed 作用域中，例如Servlet框架的HttpSession。如果使用的是web框架，可以将其放到HTTP 请求的作用域中。换句话说就是，接收到HTTP请求的时候可以打开SqlSesslion连接，响应的时候关闭。关闭SqlSession非常的重要，永远记得将其放在finally块中来关闭他。下面这个例子就是确保在finally中关闭SqlSesslion<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SqlSession session = sqlSessionFactory.openSession();</div><div class="line">try &#123;</div><div class="line">  // do work</div><div class="line">&#125; finally &#123;</div><div class="line">  session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;使用这个模式可以保证你的代码关闭了数据库的连接。</p>
<h5 id="Mapper-Instances"><a href="#Mapper-Instances" class="headerlink" title="Mapper Instances"></a>Mapper Instances</h5><p>&emsp;&emsp;Mappers是你创建用来绑定映射语句的接口。每一个mapper实例都从SqlSession中获取。因此mapper的作用域和获取他们的SqlSession的作用域是一样的。然而mapper最好的租用与是方法作用域。他们应该在一个方法使用时创建，方法结束时丢弃。他们不需要显示的关闭。和SqlSession相同，将它们放到请求作用域中也是没问题的，但是在这个层次上处理如此多的资源会很棘手。所以就简单一点，把mapper实例放到方法作用域中，下面这个例子解释了如何使用他<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SqlSession session = sqlSessionFactory.openSession();</div><div class="line">try &#123;</div><div class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</div><div class="line">  // do work</div><div class="line">&#125; finally &#123;</div><div class="line">  session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.mybatis.org/mybatis-3/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; cla
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="Mybatis" scheme="https://mashuai.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>OKHttp 拦截器</title>
    <link href="https://mashuai.github.io/2017/03/19/okhttp/interceptors/"/>
    <id>https://mashuai.github.io/2017/03/19/okhttp/interceptors/</id>
    <published>2017-03-19T07:47:42.000Z</published>
    <updated>2017-03-21T11:39:28.350Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="external">原文地址</a><br>&emsp;&emsp;拦截器是一种监控，重写，重试请求的强大机制。下面这个例子是一个记录出发出请求和接受响应的简单的拦截器的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class LoggingInterceptor implements Interceptor &#123;</div><div class="line">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</div><div class="line">    Request request = chain.request();</div><div class="line"></div><div class="line">    long t1 = System.nanoTime();</div><div class="line">    logger.info(String.format(&quot;Sending request %s on %s%n%s&quot;,</div><div class="line">        request.url(), chain.connection(), request.headers()));</div><div class="line"></div><div class="line">    Response response = chain.proceed(request);</div><div class="line"></div><div class="line">    long t2 = System.nanoTime();</div><div class="line">    logger.info(String.format(&quot;Received response for %s in %.1fms%n%s&quot;,</div><div class="line">        response.request().url(), (t2 - t1) / 1e6d, response.headers()));</div><div class="line"></div><div class="line">    return response;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;调用<code>chain.proceed(request)</code>是每个拦截器最重要的实现。这个看起来简单的方法是所有HTTP工作的地方，也是对请求响应的地方。<br>&emsp;&emsp;拦截器可以链式调用。假设你有一个压缩的拦截器和一个校验和的拦截器：你要先确定是先压缩再校验，还是先校验再压缩。OKHTTP使用列表跟踪拦截器，而且拦截器是顺序取消的。<br><img src="https://raw.githubusercontent.com/wiki/square/okhttp/interceptors@2x.png" alt="Interceptors"></p>
<h4 id="应用拦截器"><a href="#应用拦截器" class="headerlink" title="应用拦截器"></a>应用拦截器</h4><p>&emsp;&emsp;拦截器注册为应用拦截器或者网络拦截器。我们将使用上面定义的<code>LoggingInterceptor</code>来展示这两者的不同。<br>&emsp;&emsp;通过调用<code>OkHttpClient.Builder</code>的<code>addInterceptor()</code>来注册一个应用拦截器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">    .addInterceptor(new LoggingInterceptor())</div><div class="line">    .build();</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)</div><div class="line">    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">response.body().close();</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;链接<code>http://www.publicobject.com/helloworld.txt</code>重定向到链接<code>http://www.publicobject.com/helloworld.txt</code>,OKHttp回自动重定向。应用拦截器只会被调用一次。<code>chain.proceed()</code>返回的响应是重定向之后的响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">INFO: Sending request http://www.publicobject.com/helloworld.txt on null</div><div class="line">User-Agent: OkHttp Example</div><div class="line"></div><div class="line">INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms</div><div class="line">Server: nginx/1.4.6 (Ubuntu)</div><div class="line">Content-Type: text/plain</div><div class="line">Content-Length: 1759</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;因为<code>response.request().url()</code>和<code>request.url()</code>获取的URL不同，所以可以得出上述结论。两行日志记录了两个不同的URL。</p>
<h4 id="网络拦截器"><a href="#网络拦截器" class="headerlink" title="网络拦截器"></a>网络拦截器</h4><p>&emsp;&emsp;注册网络拦截器和应用拦截器差不多，只是用<code>addNetworkInterceptor()</code>代替了<code>addInterceptor()</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">    .addNetworkInterceptor(new LoggingInterceptor())</div><div class="line">    .build();</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url(&quot;http://www.publicobject.com/helloworld.txt&quot;)</div><div class="line">    .header(&quot;User-Agent&quot;, &quot;OkHttp Example&quot;)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">response.body().close();</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;当运行这段代码的时候拦截器运行了两次，一次初始的地址<code>http://www.publicobject.com/helloworld.txt</code>，一次是重定向的地址<code>https://publicobject.com/helloworld.txt</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection&#123;www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1&#125;</div><div class="line">User-Agent: OkHttp Example</div><div class="line">Host: www.publicobject.com</div><div class="line">Connection: Keep-Alive</div><div class="line">Accept-Encoding: gzip</div><div class="line"></div><div class="line">INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms</div><div class="line">Server: nginx/1.4.6 (Ubuntu)</div><div class="line">Content-Type: text/html</div><div class="line">Content-Length: 193</div><div class="line">Connection: keep-alive</div><div class="line">Location: https://publicobject.com/helloworld.txt</div><div class="line"></div><div class="line">INFO: Sending request https://publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1&#125;</div><div class="line">User-Agent: OkHttp Example</div><div class="line">Host: publicobject.com</div><div class="line">Connection: Keep-Alive</div><div class="line">Accept-Encoding: gzip</div><div class="line"></div><div class="line">INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms</div><div class="line">Server: nginx/1.4.6 (Ubuntu)</div><div class="line">Content-Type: text/plain</div><div class="line">Content-Length: 1759</div><div class="line">Connection: keep-alive</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;网络请求同时也包含了更多的数据，例如:由OKHttp添加的用来支持响应压缩的<code>Accept-Encoding: gzip</code>header。网络拦截器的<code>chain</code>有一个非空的<code>Connection</code>，用来查询连接服务器的IP地址和TLS配置信息。</p>
<h4 id="如何选择拦截器"><a href="#如何选择拦截器" class="headerlink" title="如何选择拦截器"></a>如何选择拦截器</h4><p>&emsp;&emsp;每种拦截器都有优点。</p>
<h5 id="应用拦截器-1"><a href="#应用拦截器-1" class="headerlink" title="应用拦截器"></a>应用拦截器</h5><ul>
<li>无需关心像重试，重定向等这样的中间过程。</li>
<li>即使是从缓存响应，也会调用一次。</li>
<li>只关心应用最初的目的，并不需要关心OKHttp注入的header，例如<code>If-None-Match</code></li>
<li>允许短路，不执行<code>Chain.proceed()</code></li>
<li>允许重试，执行多次<code>Chain.proceed()</code><h5 id="网络拦截器-1"><a href="#网络拦截器-1" class="headerlink" title="网络拦截器"></a>网络拦截器</h5></li>
<li>可以操作想重试，重定向这样的中间过程。</li>
<li>短路网络连接的从cache返回响应的时候不执行。</li>
<li>可以监控呗发送到网络上的数据</li>
<li>访问包含request的<code>Connection</code><h4 id="重写请求"><a href="#重写请求" class="headerlink" title="重写请求"></a>重写请求</h4>&emsp;&emsp;拦截器可以添加，删除，替换请求头。如果请求有请求体，拦截器也可以转换请求体。例如：如果远程连接的服务器支持压缩，可以使用应用拦截器添加压缩请求体的拦截器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/** This interceptor compresses the HTTP request body. Many webservers can&apos;t handle this! */</div><div class="line">final class GzipRequestInterceptor implements Interceptor &#123;</div><div class="line">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</div><div class="line">    Request originalRequest = chain.request();</div><div class="line">    if (originalRequest.body() == null || originalRequest.header(&quot;Content-Encoding&quot;) != null) &#123;</div><div class="line">      return chain.proceed(originalRequest);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request compressedRequest = originalRequest.newBuilder()</div><div class="line">        .header(&quot;Content-Encoding&quot;, &quot;gzip&quot;)</div><div class="line">        .method(originalRequest.method(), gzip(originalRequest.body()))</div><div class="line">        .build();</div><div class="line">    return chain.proceed(compressedRequest);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private RequestBody gzip(final RequestBody body) &#123;</div><div class="line">    return new RequestBody() &#123;</div><div class="line">      @Override public MediaType contentType() &#123;</div><div class="line">        return body.contentType();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public long contentLength() &#123;</div><div class="line">        return -1; // We don&apos;t know the compressed length in advance!</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public void writeTo(BufferedSink sink) throws IOException &#123;</div><div class="line">        BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));</div><div class="line">        body.writeTo(gzipSink);</div><div class="line">        gzipSink.close();</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="重写响应"><a href="#重写响应" class="headerlink" title="重写响应"></a>重写响应</h4><p>&emsp;&emsp;同样拦截器也可以重写响应，转化请求体。通常这样做比重写请求头更危险，因为这样做可能返回的并不是服务器预期值。<br>&emsp;&emsp;如果你处在一个比较棘手的场景，并且准备处理后果，重写响应头就是一个很好的方式处理这类问题。例如：可以修复服务器未配置的<code>Cache-Control</code>来获取更好的缓存响应配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/** Dangerous interceptor that rewrites the server&apos;s cache-control header. */</div><div class="line">private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor() &#123;</div><div class="line">  @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123;</div><div class="line">    Response originalResponse = chain.proceed(chain.request());</div><div class="line">    return originalResponse.newBuilder()</div><div class="line">        .header(&quot;Cache-Control&quot;, &quot;max-age=60&quot;)</div><div class="line">        .build();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通常为了补充服务器相应的修复，这个方法是最好的。</p>
<h4 id="那些可以使用拦截器"><a href="#那些可以使用拦截器" class="headerlink" title="那些可以使用拦截器"></a>那些可以使用拦截器</h4><p>&emsp;&emsp;使用拦截器要求OKHttp 2.0即以上。不行的是拦截器不可以和<code>OkUrlFactory</code>，或者依赖于他的库同时使用，包括<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit</a>1.8以下，<a href="http://square.github.io/picasso/" target="_blank" rel="external">Picasso</a>2.4以下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/square/okhttp/wiki/Interceptors&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;&amp;emsp;&amp;emsp;拦截器是一种监控，重写，重试请求的强大机制
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="HTTP" scheme="https://mashuai.github.io/tags/HTTP/"/>
    
      <category term="OKHttp" scheme="https://mashuai.github.io/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>OKHttp Recipes</title>
    <link href="https://mashuai.github.io/2017/03/18/okhttp/Recipes/"/>
    <id>https://mashuai.github.io/2017/03/18/okhttp/Recipes/</id>
    <published>2017-03-18T11:44:10.000Z</published>
    <updated>2018-04-17T01:47:30.625Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/square/okhttp/wiki/Recipes" target="_blank" rel="external">原文地址</a><br>我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。</p>
<h4 id="同步GET"><a href="#同步GET" class="headerlink" title="同步GET"></a>同步GET</h4><p>可以用来下载文件，打印header，打印body。<code>string()</code>方法对于小文档的响应来说是个既方便有高效的方法。但是如果一个文档太大（大于1M），就不要使用<code>string()</code>方法了，以为他会把整个文档加载到内存中,在这种情况下可以把body当作流来处理。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</div><div class="line"></div><div class="line">Headers responseHeaders = response.headers();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaders.size(); i++) &#123;</div><div class="line">System.out.println(responseHeaders.name(i) + <span class="string">": "</span> + responseHeaders.value(i));</div><div class="line">&#125;</div><div class="line">System.out.println(response.body().string());</div></pre></td></tr></table></figure>
<h4 id="异步GET"><a href="#异步GET" class="headerlink" title="异步GET"></a>异步GET</h4><p>在工作线程下载文件，响应可读后回调。在响应的header准备好的时候回调。响应体可能仍然阻塞。现在OKHttp没有提供获取响应体的异步API。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url("http://publicobject.com/helloworld.txt")</div><div class="line">    .build();</div><div class="line"></div><div class="line">client.newCall(request).enqueue(new Callback() &#123;</div><div class="line">    @Override public void onFailure(Call call, IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override public void onResponse(Call call, Response response) throws IOException &#123;</div><div class="line">    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);</div><div class="line"></div><div class="line">    Headers responseHeaders = response.headers();</div><div class="line">    for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123;</div><div class="line">        System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    System.out.println(response.body().string());</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">```  </div><div class="line"></div><div class="line">#### 访问Header</div><div class="line">总体上说Header有点像`Map&lt;String,String&gt;`，每一个字段都有或没有值。但是一些Header允许有多个值，就像Guava的`[Multimap](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html)`。</div><div class="line">例如HTTP提供多个`Vary`的值是很常见并且合法的。OKHttp的API在这两种情况下都能轻松使用。</div><div class="line">当写入请求header的时候使用`header(name,value)`设置仅有一个的`name`和`value`。如果有存在的值，会先移除值再添加。 使用`addHeader(name,value)`添加header不会移除已经存在的header。</div><div class="line">当读响应header的时候，`header(name)`只返回最后一个值，通常也仅有一个。如果没有值，将会返回null。以一个list的方式获取所有的值可以使用`headers(name)`。</div><div class="line">如果要访问所有的header，可以使用Headers类，支持坐标访问。</div><div class="line"></div><div class="line">```Java</div><div class="line">private final OkHttpClient client = new OkHttpClient();</div><div class="line"></div><div class="line">public void run() throws Exception &#123;</div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url("https://api.github.com/repos/square/okhttp/issues")</div><div class="line">    .header("User-Agent", "OkHttp Headers.java")</div><div class="line">    .addHeader("Accept", "application/json; q=0.5")</div><div class="line">    .addHeader("Accept", "application/vnd.github.v3+json")</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);</div><div class="line"></div><div class="line">System.out.println("Server: " + response.header("Server"));</div><div class="line">System.out.println("Date: " + response.header("Date"));</div><div class="line">System.out.println("Vary: " + response.headers("Vary"));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用POST发送String请求。"><a href="#使用POST发送String请求。" class="headerlink" title="使用POST发送String请求。"></a>使用POST发送String请求。</h4><p>使用HTTP的POST给服务发送请求。这个例子发送了一个markdown文档到服务器用来将markdown渲染成HTML。因为整个请求是放在内存中的，所以使用此API的时候避免大文档（小于1M）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</div><div class="line">    = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">String postBody = <span class="string">""</span></div><div class="line">    + <span class="string">"Releases\n"</span></div><div class="line">    + <span class="string">"--------\n"</span></div><div class="line">    + <span class="string">"\n"</span></div><div class="line">    + <span class="string">" * _1.0_ May 6, 2013\n"</span></div><div class="line">    + <span class="string">" * _1.1_ June 15, 2013\n"</span></div><div class="line">    + <span class="string">" * _1.2_ August 11, 2013\n"</span>;</div><div class="line"></div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</div><div class="line">    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用POST发送流"><a href="#使用POST发送流" class="headerlink" title="使用POST发送流"></a>使用POST发送流</h4><p>使用POST将请求体以流的方式发送。请求体在被写入的时候生成。这个例子直接使用了<code>[Okio](https://github.com/square/okio)</code>的缓冲库。可能你更熟悉<code>OutputStream</code>可以通过<code>BufferedSink.outputStream</code>获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</div><div class="line">    = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">RequestBody requestBody = <span class="keyword">new</span> RequestBody() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> MediaType <span class="title">contentType</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> MEDIA_TYPE_MARKDOWN;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(BufferedSink sink)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    sink.writeUtf8(<span class="string">"Numbers\n"</span>);</div><div class="line">    sink.writeUtf8(<span class="string">"-------\n"</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">997</span>; i++) &#123;</div><div class="line">        sink.writeUtf8(String.format(<span class="string">" * %s = %s\n"</span>, i, factor(i)));</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">factor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</div><div class="line">        <span class="keyword">int</span> x = n / i;</div><div class="line">        <span class="keyword">if</span> (x * i == n) <span class="keyword">return</span> factor(x) + <span class="string">" × "</span> + i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Integer.toString(n);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</div><div class="line">    .post(requestBody)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用POST发送一个文件"><a href="#使用POST发送一个文件" class="headerlink" title="使用POST发送一个文件"></a>使用POST发送一个文件</h4><p>文件很容易当作一个请求体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_MARKDOWN</div><div class="line">    = MediaType.parse(<span class="string">"text/x-markdown; charset=utf-8"</span>);</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"README.md"</span>);</div><div class="line"></div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"https://api.github.com/markdown/raw"</span>)</div><div class="line">    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发送form-参数"><a href="#发送form-参数" class="headerlink" title="发送form 参数"></a>发送form 参数</h4><p>使用<code>FormBody.Builder</code>来创建一个同HTML 的<code>form</code>标签方式相同的请求踢。名字和值会被编码成HTML兼容的URL编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">RequestBody formBody = <span class="keyword">new</span> FormBody.Builder()</div><div class="line">    .add(<span class="string">"search"</span>, <span class="string">"Jurassic Park"</span>)</div><div class="line">    .build();</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"https://en.wikipedia.org/w/index.php"</span>)</div><div class="line">    .post(formBody)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="发送multipart请求"><a href="#发送multipart请求" class="headerlink" title="发送multipart请求"></a>发送multipart请求</h4><p><code>MultipartBody.Builder</code>可以创建和HTML上传文件兼容的请求。每一个multipart请求体自身也是请求体，可以有自己的header。如果提供了，这些header仅描述自身的一部分，例如<code>Content-Dispositon</code>。<code>Content-Type</code>,<code>Content-Length</code>如果可用会自动添加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMGUR_CLIENT_ID = <span class="string">"..."</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType MEDIA_TYPE_PNG = MediaType.parse(<span class="string">"image/png"</span>);</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="comment">// Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image</span></div><div class="line">RequestBody requestBody = <span class="keyword">new</span> MultipartBody.Builder()</div><div class="line">    .setType(MultipartBody.FORM)</div><div class="line">    .addFormDataPart(<span class="string">"title"</span>, <span class="string">"Square Logo"</span>)</div><div class="line">    .addFormDataPart(<span class="string">"image"</span>, <span class="string">"logo-square.png"</span>,</div><div class="line">        RequestBody.create(MEDIA_TYPE_PNG, <span class="keyword">new</span> File(<span class="string">"website/static/logo-square.png"</span>)))</div><div class="line">    .build();</div><div class="line"></div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .header(<span class="string">"Authorization"</span>, <span class="string">"Client-ID "</span> + IMGUR_CLIENT_ID)</div><div class="line">    .url(<span class="string">"https://api.imgur.com/3/image"</span>)</div><div class="line">    .post(requestBody)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用Gson解析响应JSON"><a href="#使用Gson解析响应JSON" class="headerlink" title="使用Gson解析响应JSON"></a>使用Gson解析响应JSON</h4><p><a href="http://code.google.com/p/google-gson/" target="_blank" rel="external">Gson</a>是一个很顺手的转换Java对象和JSON的API。这里我们用它来解析GitHub响应的JSON。<br>注意，<code>ResponseBody.charStream()</code>使用<code>content-type</code>的响应header来选择解码响应流的字符集，如果没有提供默认使用UTF-8。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Gson gson = <span class="keyword">new</span> Gson();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"https://api.github.com/gists/c2a7c39532239ff261be"</span>)</div><div class="line">    .build();</div><div class="line">Response response = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</div><div class="line"></div><div class="line">Gist gist = gson.fromJson(response.body().charStream(), Gist.class);</div><div class="line"><span class="keyword">for</span> (Map.Entry&lt;String, GistFile&gt; entry : gist.files.entrySet()) &#123;</div><div class="line">    System.out.println(entry.getKey());</div><div class="line">    System.out.println(entry.getValue().content);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Gist</span> </span>&#123;</div><div class="line">Map&lt;String, GistFile&gt; files;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GistFile</span> </span>&#123;</div><div class="line">String content;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="响应缓存"><a href="#响应缓存" class="headerlink" title="响应缓存"></a>响应缓存</h4><p>为了换成响应需要又一个可读写的缓存目录并且限制缓存的大小。缓存目录应该是私有的，并且非信任的应用无权访问。<br>同时访问一个缓冲目录回出现错误。大多数应用应该调用一次<code>new OkHttpClient()</code>，配置它的缓存，在其他地方使用统一个实例。否则两个缓存实例会互相损害，损坏换成，可能是你的应用崩溃。<br>响应缓存使用HTTP的header来配置。如果请求头添加了<code>Cache-Control: max-stale=3600</code>,OKHttp将会使用这些配置。是服务器来配置响应可以被缓存多长时间，通过响应头来配置，例如<code>Cache-Control: max-age=9600</code>。有一些header可以强制换成响应，强制一个网络返回或者强制一个有条件的GET确定缓存是否有效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheResponse</span><span class="params">(File cacheDirectory)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="keyword">int</span> cacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 10 MiB</span></div><div class="line">Cache cache = <span class="keyword">new</span> Cache(cacheDirectory, cacheSize);</div><div class="line"></div><div class="line">client = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">    .cache(cache)</div><div class="line">    .build();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response1 = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response1.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response1);</div><div class="line"></div><div class="line">String response1Body = response1.body().string();</div><div class="line">System.out.println(<span class="string">"Response 1 response:          "</span> + response1);</div><div class="line">System.out.println(<span class="string">"Response 1 cache response:    "</span> + response1.cacheResponse());</div><div class="line">System.out.println(<span class="string">"Response 1 network response:  "</span> + response1.networkResponse());</div><div class="line"></div><div class="line">Response response2 = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response2.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response2);</div><div class="line"></div><div class="line">String response2Body = response2.body().string();</div><div class="line">System.out.println(<span class="string">"Response 2 response:          "</span> + response2);</div><div class="line">System.out.println(<span class="string">"Response 2 cache response:    "</span> + response2.cacheResponse());</div><div class="line">System.out.println(<span class="string">"Response 2 network response:  "</span> + response2.networkResponse());</div><div class="line"></div><div class="line">System.out.println(<span class="string">"Response 2 equals Response 1? "</span> + response1Body.equals(response2Body));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了阻止缓冲可以使用<code>[CacheControl.FORCE_NETWORK](CacheControl.FORCE_NETWORK)</code>.为了阻止网络连接可以使用<code>[CacheControl.FORCE_CACHE](http://square.github.io/okhttp/3.x/okhttp/okhttp3/CacheControl.html#FORCE_CACHE)</code>。警告：如果使用了<code>FORCE_CACHE</code>并且响应需要网络，将会返回<code>504 Unsatisfiable Request</code>。</p>
<h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><p>使用<code>Call.cancel()</code>立即取消正在进行的请求。如果一个线程正在写一个请求或者读一个响应将会抛出IOException。当一个请求不在需要的时候使用这个函数来保护网络。例如当用户导航离开应用的时候。同步和异步的请求都可以取消。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">1</span>);</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></div><div class="line">    .build();</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="keyword">long</span> startNanos = System.nanoTime();</div><div class="line"><span class="keyword">final</span> Call call = client.newCall(request);</div><div class="line"></div><div class="line"><span class="comment">// Schedule a job to cancel the call in 1 second.</span></div><div class="line">executor.schedule(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.printf(<span class="string">"%.2f Canceling call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</div><div class="line">    call.cancel();</div><div class="line">    System.out.printf(<span class="string">"%.2f Canceled call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    System.out.printf(<span class="string">"%.2f Executing call.%n"</span>, (System.nanoTime() - startNanos) / <span class="number">1e9f</span>);</div><div class="line">    Response response = call.execute();</div><div class="line">    System.out.printf(<span class="string">"%.2f Call was expected to fail, but completed: %s%n"</span>,</div><div class="line">        (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, response);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    System.out.printf(<span class="string">"%.2f Call failed as expected: %s%n"</span>,</div><div class="line">        (System.nanoTime() - startNanos) / <span class="number">1e9f</span>, e);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h4><p>当端点不可达的时候使用超时使请求失败。网络分区可能是客户端连接问题，服务器可用性问题或者其他问题。OKHttp支持连接，读，写超时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConfigureTimeouts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">client = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">    .connectTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</div><div class="line">    .writeTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</div><div class="line">    .readTimeout(<span class="number">30</span>, TimeUnit.SECONDS)</div><div class="line">    .build();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"http://httpbin.org/delay/2"</span>) <span class="comment">// This URL is served with a 2 second delay.</span></div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line">System.out.println(<span class="string">"Response completed: "</span> + response);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="调用前配置"><a href="#调用前配置" class="headerlink" title="调用前配置"></a>调用前配置</h4><p>所有的HTTP调用配置都会在<code>OkHttpClient</code>中，包括，代理设置，超时和缓存。当需要修改某个调用的配置的时候，使用<code>OKHttpClient.newBuilder()</code>。这个函数会返回共享的连接池，调度器，并且跟原始client相同的配置。在下面这个例子中，一个请求的超时时间是500ms另一个是3000ms。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"http://httpbin.org/delay/1"</span>) <span class="comment">// This URL is served with a 1 second delay.</span></div><div class="line">    .build();</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// Copy to customize OkHttp for this request.</span></div><div class="line">    OkHttpClient copy = client.newBuilder()</div><div class="line">        .readTimeout(<span class="number">500</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .build();</div><div class="line"></div><div class="line">    Response response = copy.newCall(request).execute();</div><div class="line">    System.out.println(<span class="string">"Response 1 succeeded: "</span> + response);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    System.out.println(<span class="string">"Response 1 failed: "</span> + e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// Copy to customize OkHttp for this request.</span></div><div class="line">    OkHttpClient copy = client.newBuilder()</div><div class="line">        .readTimeout(<span class="number">3000</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .build();</div><div class="line"></div><div class="line">    Response response = copy.newCall(request).execute();</div><div class="line">    System.out.println(<span class="string">"Response 2 succeeded: "</span> + response);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    System.out.println(<span class="string">"Response 2 failed: "</span> + e);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="处理认证"><a href="#处理认证" class="headerlink" title="处理认证"></a>处理认证</h4><p>OKHttp会自动重试认证请求。当响应是<code>401 Not Authorized</code>,<code>Authenticator</code>需要用来提供凭证。将会重新实现一个带有凭证的请求，如果没有凭证可用跳过重试，返回null。<br>使用<code>Response.challenges()</code>来获取任何认证口令的方案和域。当使用<code>Basic</code>认证的时候使用<code>Credentials.basic(username,password)</code>来编码一个header。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Authenticate</span><span class="params">()</span> </span>&#123;</div><div class="line">client = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">    .authenticator(<span class="keyword">new</span> Authenticator() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">authenticate</span><span class="params">(Route route, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Authenticating for response: "</span> + response);</div><div class="line">        System.out.println(<span class="string">"Challenges: "</span> + response.challenges());</div><div class="line">        String credential = Credentials.basic(<span class="string">"jesse"</span>, <span class="string">"password1"</span>);</div><div class="line">        <span class="keyword">return</span> response.request().newBuilder()</div><div class="line">            .header(<span class="string">"Authorization"</span>, credential)</div><div class="line">            .build();</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    .build();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"http://publicobject.com/secrets/hellosecret.txt"</span>)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Response response = client.newCall(request).execute();</div><div class="line"><span class="keyword">if</span> (!response.isSuccessful()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected code "</span> + response);</div><div class="line"></div><div class="line">System.out.println(response.body().string());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/square/okhttp/wiki/Recipes&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;我们写了一些建议，来演示如何使用OKHttp来解决一些常见问题。&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="HTTP" scheme="https://mashuai.github.io/tags/HTTP/"/>
    
      <category term="OKHttp" scheme="https://mashuai.github.io/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>OKHttp connections</title>
    <link href="https://mashuai.github.io/2017/03/18/okhttp/connections/"/>
    <id>https://mashuai.github.io/2017/03/18/okhttp/connections/</id>
    <published>2017-03-18T11:05:48.000Z</published>
    <updated>2017-03-21T02:20:32.570Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/square/okhttp/wiki/Connections" target="_blank" rel="external">原文地址</a><br>&emsp;&emsp;虽然只提供了URL，但是OKHttp会使用URL，Address，Route三种方式来连接服务器。</p>
<h4 id="URLS"><a href="#URLS" class="headerlink" title="URLS"></a>URLS</h4><p>&emsp;&emsp;URLs例如（<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a>) 是HTTP和Internet的基础。除了是一个表示互联网一切的命名方案，也指定了如何访问Web资源。<br>URLs是抽象的：</p>
<ul>
<li>它指出，调用可以是纯文本（http）或者加密（https），但是并没有指定一种加密算法。也没有指定如何验证各个端点的证书(<a href="http://developer.android.com/reference/javax/net/ssl/HostnameVerifier.html" target="_blank" rel="external">HostnameVerifier</a>)，或者是哪个证书可信(<a href="http://developer.android.com/reference/org/apache/http/conn/ssl/SSLSocketFactory.html" target="_blank" rel="external">SSLSocketFactory</a>)</li>
<li><p>它为指定是否需要使用代理服务器以及代理服务器如何授权。<br>&emsp;&emsp;它也是具体的，每个URL标识一个具体的路径（/square/okhttp)和查询（?q=sharks&amp;lang=en)。每个服务器有很多URL。</p>
<h4 id="Addresses"><a href="#Addresses" class="headerlink" title="Addresses"></a>Addresses</h4><p>&emsp;&emsp;Address指定了一个服务器（例如：github.com），以及连接服务器必要的所有的静态配置，包括：端口号，HTTPS设置，优先协议（例如，HTTP／2，SPDY）。<br>&emsp;&emsp;URL使用了相同的Address，底层也可能实用了相同的TCP链接。复用连接可以提高性能：低延迟，高吞吐（<a href="http://www.igvita.com/2011/10/20/faster-web-vs-tcp-slow-start/" target="_blank" rel="external">TCP 慢启动</a>)，低电量。OKHttp使用<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/ConnectionPool.html" target="_blank" rel="external">ConnectionPool</a>自动复用HTTP／1.x连接，多路复用HTT／2和SPDY的连接。<br>&emsp;&emsp;在OKHttp，address的一些字段来源于URL（协议，主机名，端口），剩下的来自<a href="http://square.github.io/okhttp/3.x/okhttp/okhttp3/OkHttpClient.html" target="_blank" rel="external">OKHttpClient</a>。</p>
<h4 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h4><p>&emsp;&emsp;Route提供了连接服务器必要的动态信息。包括，具体的IP地址（通过DNS查询），具体使用那个代理（<a href="http://developer.android.com/reference/java/net/ProxySelector.html" target="_blank" rel="external">ProxySelector</a>），协n哪个TLS版本（HTTPS).<br>&emsp;&emsp;一个服务器可能有多条路有信息。例如：多台服务器部署在多个数据中心，DNS查询返回多个IP地址。</p>
<h4 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h4><p>&emsp;&emsp;当发起一个URL的请求的时候：</p>
<ol>
<li>使用URL和OKHttpCLient确定具体的<strong>Address</strong>。这个地址明确如何连接服务器。</li>
<li>尝试从<strong>连接池</strong>中查找具体Address的连接。</li>
<li>如果未找到有效的连接，使用Route来尝试获取。一般这样意味着通过DNS或去IP地址。然后，如果需要，选择一个TLS的版本和代理服务器。</li>
<li>如果是一个新的Route，要么使用Socket直连，TLS隧道（HTTS方式），或者直接使用TLS。也会进行必要的TLS握手。</li>
<li>发送请求，接受响应。<br>&emsp;&emsp;如果连接发生错误，OKHttp会选择另一个路由重试。这样OKHttp就可以在服务器端一些地址无法访问的时候恢复访问。同时如果连接池的连接失效或者常识的TLS 版本不支持也很有用。<br>&emsp;&emsp;当响应接收到了之后，连接会放回到连接池以便之后使用。连接在一段时间过期后回被移除连接池。</li>
</ol>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/square/okhttp/wiki/Connections&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;&amp;emsp;&amp;emsp;虽然只提供了URL，但是OKHttp会使用U
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="HTTP" scheme="https://mashuai.github.io/tags/HTTP/"/>
    
      <category term="OKHttp" scheme="https://mashuai.github.io/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>OKHttp的调用</title>
    <link href="https://mashuai.github.io/2017/03/18/okhttp/calls/"/>
    <id>https://mashuai.github.io/2017/03/18/okhttp/calls/</id>
    <published>2017-03-18T07:10:03.000Z</published>
    <updated>2017-03-21T11:39:23.317Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/square/okhttp/wiki/Calls" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp;HTTP客户端的任务是接受请求和产生响应。理论很简单，但是实战的时候就有点棘手了。</p>
<h4 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h4><p>&emsp;&emsp;每一个HTTP请求都包含一个URL，一个方法（例如，GET，POST）和一些headers。请求同时可以包含一个特定类型的数据流作为body。</p>
<h4 id="Responses"><a href="#Responses" class="headerlink" title="Responses"></a>Responses</h4><p>&emsp;&emsp;Response 通过一个一个状态码（例如，200 成功，404未找到），headers，和一个可选的Body来响应请求。</p>
<h5 id="重写请求"><a href="#重写请求" class="headerlink" title="重写请求"></a>重写请求</h5><p>&emsp;&emsp;当使用OkHttp发送HTTP请求的时候，可以在高层次描述这个请求：通过这个URL和这些headers来获取响应。为了准确和更高的效率，OKHttp会在发送之前重现请求。<br>&emsp;&emsp;OkHttp将会添加原请求没有的header，包括<code>Content-length</code>,<code>Transfer-Encoding</code>,<code>User-Agent</code>,<code>Host</code>,<code>Connection</code>，<code>Content-Type</code>。除非已经提供了，否则OKHttp回会添加 <code>Acceept-Encoding</code>来压缩响应。如果有Cookie，也会添加<code>Cookie</code>。<br>&emsp;&emsp;有些请求会缓存响应。当被缓存的响应过期后，OKHttp会发送一个有条件的GET请求来获取新的响应，如果新现在的比缓存的响应更新，将会更新缓存过的响应。这要求<code>If-Modified-Since</code>和<code>If-None-Match</code>添加到headers中。</p>
<h5 id="重写响应"><a href="#重写响应" class="headerlink" title="重写响应"></a>重写响应</h5><p>&emsp;&emsp;如果透明压缩启用了，OKHttp将会把<code>Content-Encoding</code>和<code>Content-Length</code>从headers中移除，因为他们不是用来解压缩的。<br>&emsp;&emsp;如果条件GET请求成功，从网上下载的响应和缓存的响应根据Spec合并。</p>
<h5 id="后续请求"><a href="#后续请求" class="headerlink" title="后续请求"></a>后续请求</h5><p>&emsp;&emsp;当请求的URL被转移了，web server 将会返回一个302的状态码来表示这个文档的新URL，OKHttp将会重定向到新的URL获取最终的响应。<br>&emsp;&emsp;如果响应需要认证，OKHttp将会使用<code>Authenticator</code>（如果提供了一个）来认证。如果认证器提供了凭证，请求回使用凭证重试。</p>
<h5 id="重试请求"><a href="#重试请求" class="headerlink" title="重试请求"></a>重试请求</h5><p>&emsp;&emsp;有时连接失败，例如：连接池过期断开链接，或者无法连接服务器。OKHttp会通过不同的可用路由来重试请求。</p>
<h4 id="calls"><a href="#calls" class="headerlink" title="calls"></a>calls</h4><p>&emsp;&emsp;通过重写，重定向，继续请求和重试，一个简单的请求可能会产生很多请求和响应。OKHttp使用<code>call</code>建立一个不管多少中间请求和响应的任务模型。总的来说这不多。但是了解代码将会继续工作，不管是URL重定向或者是转移故障其他IP。<br>&emsp;&emsp;call有两种工作方</p>
<ul>
<li>同步：线程将会阻塞道到响应可读。</li>
<li>异步：将请求加入到其他线程的队列，当响应可读诗时，会在其他的线程获取回调。<br>&emsp;&emsp;请求调用可以在任何线程取消。如果调用未完成，这个请求将会失败。当调用取消时，在先请求踢体或者读响应体的代码将会跑出IOException的异常。<h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5>&emsp;&emsp;对于同步调用，将会由自身线程控制多少并发请求。太多并发连接浪费资源，太少又回有高延迟。<br>&emsp;&emsp;对于异步来说，Dispatcher实现了最大并发的策略。可以设置没个服务器的最大并发（默认是5）和总体的并发（默认64）。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/square/okhttp/wiki/Calls&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;HTTP客户端的任务是接受请求和产生响应。理论很
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Java" scheme="https://mashuai.github.io/tags/Java/"/>
    
      <category term="HTTP" scheme="https://mashuai.github.io/tags/HTTP/"/>
    
      <category term="OKHttp" scheme="https://mashuai.github.io/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>为Go Web App 创建一个主页面</title>
    <link href="https://mashuai.github.io/2015/11/14/%E4%B8%BAGo-Web-App-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%BB%E9%A1%B5%E9%9D%A2/"/>
    <id>https://mashuai.github.io/2015/11/14/为Go-Web-App-创建一个主页面/</id>
    <published>2015-11-14T09:59:00.000Z</published>
    <updated>2017-03-21T02:20:32.573Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp; 大多数web app都有一个相同的布局。这个布局可能包含一个header或者footer，甚至可能包含一个导航菜单。Go的标准库提供一个简单的方式来创建这些基本元素，通过被不同的页面重用，创建出模板页的效果。<br>&emsp;&emsp; 这个简单的例子来解释如何实现的：<br>&emsp;&emsp; 让我们来创建一个简单的包含两个view的web app，一个是 main 一个是about。这两个view都有相同的header和footer。<br>&emsp;&emsp; header模板的代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123; &#123; define "header" &#125;&#125;</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;title&gt;&#123; &#123;.Title&#125;&#125;&lt;/title&gt;</div><div class="line">        &lt;link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css"&gt;</div><div class="line">        &lt;link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-theme.min.css"&gt;</div><div class="line">        &lt;style type="text/css"&gt;</div><div class="line">            body &#123;padding-bottom: 70px;&#125;</div><div class="line">            .content &#123;margin:10px;&#125;</div><div class="line">        &lt;/style&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;nav class="navbar navbar-default" role="navigation"&gt;</div><div class="line">          &lt;div class="navbar-header"&gt;</div><div class="line">            &lt;a class="navbar-brand" href="/"&gt;Go App&lt;/a&gt;</div><div class="line">          &lt;/div&gt;</div><div class="line">          &lt;div class="collapse navbar-collapse navbar-ex1-collapse"&gt;  </div><div class="line">            &lt;ul class="nav navbar-nav"&gt;</div><div class="line">                &lt;li&gt;&lt;a href="/"&gt;Main&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href="/about"&gt;About&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;/ul&gt;</div><div class="line">          &lt;/div&gt;</div><div class="line">        &lt;/nav&gt;</div><div class="line">&#123; &#123; end &#125;&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; footer模板的代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123; &#123; define "footer" &#125;&#125;</div><div class="line">        &lt;p class="navbar-text navbar-fixed-bottom"&gt;Go Rocks!&lt;/p&gt;    </div><div class="line">        &lt;script src="//netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"&gt;&lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">&#123; &#123; end &#125;&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; main 模板的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123; &#123;define &quot;main&quot;&#125;&#125;</div><div class="line">&#123; &#123; template &quot;header&quot; .&#125;&#125;</div><div class="line">&lt;div class=&quot;content&quot;&gt;</div><div class="line">    &lt;h2&gt;Main&lt;/h2&gt;</div><div class="line">    &lt;div&gt;This is the Main page&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&#123; &#123;template &quot;footer&quot; .&#125;&#125;</div><div class="line">&#123; &#123; end&#125;&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; about 模板的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123; &#123;define &quot;about&quot;&#125;&#125;</div><div class="line">&#123; &#123; template &quot;header&quot; .&#125;&#125;</div><div class="line">&lt;div class=&quot;content&quot;&gt;</div><div class="line">    &lt;h2&gt;About&lt;/h2&gt;</div><div class="line">    &lt;div&gt;This is the About page&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&#123; &#123;template &quot;footer&quot; .&#125;&#125;</div><div class="line">&#123; &#123; end&#125;&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 服务器代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;html/template&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line">)</div><div class="line"></div><div class="line">//Compile templates on start</div><div class="line">var templates = template.Must(template.ParseFiles(&quot;header.html&quot;, &quot;footer.html&quot;, &quot;main.html&quot;, &quot;about.html&quot;))</div><div class="line"></div><div class="line">//A Page structure</div><div class="line">type Page struct &#123;</div><div class="line">    Title string</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Display the named template</div><div class="line">func display(w http.ResponseWriter, tmpl string, data interface&#123;&#125;) &#123;</div><div class="line">    templates.ExecuteTemplate(w, tmpl, data)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//The handlers.</div><div class="line">func mainHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    display(w, &quot;main&quot;, &amp;Page&#123;Title: &quot;Home&quot;&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func aboutHandler(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    display(w, &quot;about&quot;, &amp;Page&#123;Title: &quot;About&quot;&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    http.HandleFunc(&quot;/&quot;, mainHandler)</div><div class="line">    http.HandleFunc(&quot;/about&quot;, aboutHandler)</div><div class="line"></div><div class="line">    //Listen on port 8080</div><div class="line">    http.ListenAndServe(&quot;:8080&quot;, nil)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 每一个模板页都有一个 <code>{ { define &quot;name&quot; }}</code>的命令来定义模板的名字。main和about页面通过<code>{ { template &quot;name&quot; }}</code>来包含header和footer。<code>.</code> 出入上下文来命名模板。现在，不管main和about页面如何执行，他们的页面都会包含header和footer。<br>&emsp;&emsp; 两个页面的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/main.png" alt="main"><br><img src="https://raw.githubusercontent.com/mashuai/hexo-blog/master/goweb/about.png" alt="about">  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://sanatgersappa.blogspot.com/2013/11/creating-master-page-for-your-go-web-app.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Go" scheme="https://mashuai.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>http.Handler 与Go的错误处理</title>
    <link href="https://mashuai.github.io/2015/11/12/http-Handler-%E4%B8%8EGo%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://mashuai.github.io/2015/11/12/http-Handler-与Go的错误处理/</id>
    <published>2015-11-12T13:24:57.000Z</published>
    <updated>2017-03-21T02:20:32.565Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://elithrar.github.io/article/http-handler-error-handling-revisited/" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp; 在之前我写过一篇关于通过使用<code>http.HandlerFunc</code>来实现一个定制handler类型用来避免一些平常的错误的<a href="http://elithrar.github.io/article/custom-handlers-avoiding-globals/" target="_blank" rel="external">文章</a>。<code>func MyHandler(w http.ResponseWriter, r *http.Request)</code>的签名经常可以看到。这是一个有用的通用的包含一些基本功能的handler类型，但是和其他事情一样，也有一些不足：</p>
<ul>
<li>当你想要在一个handler中停止处理的时候，必须记得显示的调用一个return。这个在当你想要跑出一个从定向（301、302），未找到（404）或者服务器端错误（500）的状态的时候是很平常的。如果不这么做可能会引起一些微妙的错误（函数会继续执行），因为函数不需要一个返回值，编译器也不会警告你。</li>
<li>不容易传递额外的参数（例如，数据库连接池，配置）。你最后不得不实用一系列的全局变量（不算太坏，但是跟踪他们会导致难以扩展）或者将他们存到请求上下文中，然后每次都从其取出。这样做很笨重。</li>
<li>一直在不断的重复同样的语句。想要记录数据库包返回的错误？既可以再每个查询方法中调用<code>log.Printf</code>，也可以再每个handler中返回错误。如果你的handler可以返回给一个集中记录错误的函数，并且跑出一个500的错误就更好了。</li>
</ul>
<p>&emsp;&emsp; 我以前的方法中使用了<code>func(http.ResponseWriter, *http.Request)</code>签名。这已经被证明是一个简介的方式，但是有个奇怪的地方是，返回一个无错误的状态，例如，200,302,303往往是多余的，因为要么你已经在其他地方设置了，要么就是没用的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">func SomeHandler(w http.ResponseWriter, r *http.Request) (int, error) &#123;</div><div class="line">    db, err := someDBcall()</div><div class="line">    if err != nil &#123;</div><div class="line">        // This makes sense.</div><div class="line">        return 500, err</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if user.LoggedIn &#123;</div><div class="line">        http.Redirect(w, r, &quot;/dashboard&quot;, 302)</div><div class="line">        // Superfluous! Our http.Redirect function handles the 302, not </div><div class="line">        // our return value (which is effectively ignored).</div><div class="line">        return 302, nil</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;看起来还行，但是我们可以做的更好</p>
<h3 id="一些区别"><a href="#一些区别" class="headerlink" title="一些区别"></a>一些区别</h3><p>&emsp;&emsp; 那么我们应该如何改进它？我们先列出代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">package handler</div><div class="line"></div><div class="line">// Error represents a handler error. It provides methods for a HTTP status </div><div class="line">// code and embeds the built-in error interface.</div><div class="line">type Error interface &#123;</div><div class="line">    error</div><div class="line">    Status() int</div><div class="line">&#125;</div><div class="line"></div><div class="line">// StatusError represents an error with an associated HTTP status code.</div><div class="line">type StatusError struct &#123;</div><div class="line">    Code int</div><div class="line">    Err  error</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Allows StatusError to satisfy the error interface.</div><div class="line">func (se StatusError) Error() string &#123;</div><div class="line">    return se.Err.Error()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Returns our HTTP status code.</div><div class="line">func (se StatusError) Status() int &#123;</div><div class="line">    return se.Code</div><div class="line">&#125;</div><div class="line"></div><div class="line">// A (simple) example of our application-wide configuration.</div><div class="line">type Env struct &#123;</div><div class="line">    DB   *sql.DB</div><div class="line">    Port string</div><div class="line">    Host string</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The Handler struct that takes a configured Env and a function matching</div><div class="line">// our useful signature.</div><div class="line">type Handler struct &#123;</div><div class="line">    *Env</div><div class="line">    H func(e *Env, w http.ResponseWriter, r *http.Request) error</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ServeHTTP allows our Handler type to satisfy http.Handler.</div><div class="line">func (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    err := h.H(h.Env, w, r)</div><div class="line">    if err != nil &#123;</div><div class="line">        switch e := err.(type) &#123;</div><div class="line">        case Error:</div><div class="line">            // We can retrieve the status here and write out a specific</div><div class="line">            // HTTP status code.</div><div class="line">            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)</div><div class="line">            http.Error(w, e.Error(), e.Status())</div><div class="line">        default:</div><div class="line">            // Any error types we don&apos;t specifically look out for default</div><div class="line">            // to serving a HTTP 500</div><div class="line">            http.Error(w, http.StatusText(http.StatusInternalServerError),</div><div class="line">                http.StatusInternalServerError)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 上面的代码不言自明，但是要说明一下一些突出的观点：</p>
<ul>
<li>我们自定义了一个<code>Error</code>类型（接口），他内嵌了Go的内建的error接口，同时提供了一个<code>Status() int</code>方法。</li>
<li>我们提供了一个简单的<code>StatusError</code>类型（结构体），它满足<code>handler.Error</code>的接口。StatusError接受一个HTTP的状态码（int类型），一个可以让我们包装错误用来记录或者查询的error类型。</li>
<li>我们的<code>ServeHTTP</code>方法包好了一个”e := err.(type)”的类型断言，它可以测试我们需要处理的错误，允许我们处理那些特别的错误。在这个例子中，他是只是一个<code>handler.Error</code>类型。其他的错误，例如其他包中的错误想net.Error，或者其他我们定义的额外的错误，如果想要检查，同样也可以检查。</li>
</ul>
<p>&emsp;&emsp; 如果我们不想捕捉那些错误，那么<code>default</code>将会默认捕捉到。记住一点，<code>ServeHTTP</code>可以使我们的Handler类型满足http.Handler接口，这样他就可以在任何使用http.Handler的地方使用了，例如Go的net/http包或者所有的其他的第三方框架。这样使得定制的handler更有用，他们用起来很灵活。<br>&emsp;&emsp; 注意 net 包处理事情很简单。它又一个net.Error的接口，内嵌了内建的error接口。一些具体的类型实现了它。函数返回的具体类型跟错误的类型相同（DNS错误，解析错误等）。再datastore 包中定义的DBError有一个Query() string 方法，可以很好的解释。</p>
<h3 id="所有示例"><a href="#所有示例" class="headerlink" title="所有示例"></a>所有示例</h3><p>&emsp;&emsp; 它最后是什么样子的？我们是否可以将其分到不同的包中？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">package handler</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;net/http&quot;</div><div class="line">)</div><div class="line"></div><div class="line">// Error represents a handler error. It provides methods for a HTTP status </div><div class="line">// code and embeds the built-in error interface.</div><div class="line">type Error interface &#123;</div><div class="line">    error</div><div class="line">    Status() int</div><div class="line">&#125;</div><div class="line"></div><div class="line">// StatusError represents an error with an associated HTTP status code.</div><div class="line">type StatusError struct &#123;</div><div class="line">    Code int</div><div class="line">    Err  error</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Allows StatusError to satisfy the error interface.</div><div class="line">func (se StatusError) Error() string &#123;</div><div class="line">    return se.Err.Error()</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Returns our HTTP status code.</div><div class="line">func (se StatusError) Status() int &#123;</div><div class="line">    return se.Code</div><div class="line">&#125;</div><div class="line"></div><div class="line">// A (simple) example of our application-wide configuration.</div><div class="line">type Env struct &#123;</div><div class="line">    DB   *sql.DB</div><div class="line">    Port string</div><div class="line">    Host string</div><div class="line">&#125;</div><div class="line"></div><div class="line">// The Handler struct that takes a configured Env and a function matching</div><div class="line">// our useful signature.</div><div class="line">type Handler struct &#123;</div><div class="line">    *Env</div><div class="line">    H func(e *Env, w http.ResponseWriter, r *http.Request) error</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ServeHTTP allows our Handler type to satisfy http.Handler.</div><div class="line">func (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    err := h.H(h.Env, w, r)</div><div class="line">    if err != nil &#123;</div><div class="line">        switch e := err.(type) &#123;</div><div class="line">        case Error:</div><div class="line">            // We can retrieve the status here and write out a specific</div><div class="line">            // HTTP status code.</div><div class="line">            log.Printf(&quot;HTTP %d - %s&quot;, e.Status(), e)</div><div class="line">            http.Error(w, e.Error(), e.Status())</div><div class="line">        default:</div><div class="line">            // Any error types we don&apos;t specifically look out for default</div><div class="line">            // to serving a HTTP 500</div><div class="line">            http.Error(w, http.StatusText(http.StatusInternalServerError),</div><div class="line">                http.StatusInternalServerError)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">func GetIndex(env *Env, w http.ResponseWriter, r *http.Request) error &#123;</div><div class="line">    users, err := env.DB.GetAllUsers()</div><div class="line">    if err != nil &#123;</div><div class="line">        // We return a status error here, which conveniently wraps the error</div><div class="line">        // returned from our DB queries. We can clearly define which errors </div><div class="line">        // are worth raising a HTTP 500 over vs. which might just be a HTTP </div><div class="line">        // 404, 403 or 401 (as appropriate). It&apos;s also clear where our </div><div class="line">        // handler should stop processing by returning early.</div><div class="line">        return StatusError&#123;500, err&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fmt.Fprintf(w, &quot;%+v&quot;, users)</div><div class="line">    return nil</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; main包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;net/http&quot;</div><div class="line">    &quot;github.com/you/somepkg/handler&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    db, err := sql.Open(&quot;connectionstringhere&quot;)</div><div class="line">    if err != nil &#123;</div><div class="line">          log.Fatal(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Initialise our app-wide environment with the services/info we need.</div><div class="line">    env := &amp;handler.Env&#123;</div><div class="line">        DB: db,</div><div class="line">        Port: os.Getenv(&quot;PORT&quot;),</div><div class="line">        Host: os.Getenv(&quot;HOST&quot;),</div><div class="line">        // We might also have a custom log.Logger, our </div><div class="line">        // template instance, and a config struct as fields </div><div class="line">        // in our Env struct.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Note that we&apos;re using http.Handle, not http.HandleFunc. The </div><div class="line">    // latter only accepts the http.HandlerFunc type, which is not </div><div class="line">    // what we have here.</div><div class="line">    http.Handle(&quot;/&quot;, handler.Handler&#123;env, handler.GetIndex&#125;)</div><div class="line"></div><div class="line">    // Logs the error if ListenAndServe fails.</div><div class="line">    log.Fatal(http.ListenAndServe(&quot;:8000&quot;, nil))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 在实际使用时，会将handler和Env放入不同的包中，这里只是为了简单放在了同一个包中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://elithrar.github.io/article/http-handler-error-handling-revisited/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="Go" scheme="https://mashuai.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>使用Go开发HTTP中间件</title>
    <link href="https://mashuai.github.io/2015/11/12/%E4%BD%BF%E7%94%A8Go%E5%BC%80%E5%8F%91HTTP%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://mashuai.github.io/2015/11/12/使用Go开发HTTP中间件/</id>
    <published>2015-11-12T04:07:49.000Z</published>
    <updated>2017-03-21T02:20:32.574Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://justinas.org/writing-http-middleware-in-go/" target="_blank" rel="external">原文地址</a></p>
<p>&emsp;&emsp; 再web开发的背景下，“中间件”通常意思是“包装原始应用并添加一些额外的功能的应用的一部分”。这个概念似乎总是不被人理解，但是我认为中间件非常棒。<br>&emsp;&emsp; 首先，一个好的中间件有一个责任就是可插拔并且自足。这就意味着你可以在接口级别嵌入你的中间件他就能直接运行。它不会影响你编码方式，不是框架，仅仅是你请求处理里面的一层而已。完全没必要重写你的代码，如果你想使用中间件的一个功能，你就帮他插入到那里，如果不想使用了，就可以直接移除。<br>&emsp;&emsp; 纵观Go语言，中间件是非常普遍的，即使在标准库中。虽然开始的时候不会那么明显，在标准库<code>net/http</code>中的函数<code>StripText</code>或者<code>TimeoutHandler</code>就是我们要定义和的中间件的样子，处理请求和相应的时候他们包装你的handler，并处理一些额外的步骤。<br>&emsp;&emsp; 我最近写的Go包<a href="https://github.com/justinas/nosurf" target="_blank" rel="external">nosurf</a>同样也是个中间件。我特意将他从头开始设计。在大多数情况下，你不需要在应用层担心CSRF攻击，nosurf像其他的中间件一样可以自足，并且和<code>net/http</code>的接口无缝衔接。<br>&emsp;&emsp; 同样你还可以使用中间件做：</p>
<ul>
<li>隐藏长度防止缓冲攻击</li>
<li>速度限制</li>
<li>屏蔽爬虫</li>
<li>提供调试信息</li>
<li>添加HSTS，X-Frame-Options头</li>
<li>从错误中恢复</li>
<li>等等</li>
</ul>
<h3 id="编写一个简单的中间件"><a href="#编写一个简单的中间件" class="headerlink" title="编写一个简单的中间件"></a>编写一个简单的中间件</h3><p>&emsp;&emsp; 我们的第一个例子是写一个只允许一个域名下的用户访问的中间件，通过HTTP的<code>HOST</code>header实现。这样的中间件可以防止<a href="http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html" target="_blank" rel="external">主机欺骗攻击</a>。</p>
<h3 id="类型的机构"><a href="#类型的机构" class="headerlink" title="类型的机构"></a>类型的机构</h3><p>&emsp;&emsp; 首先我们定义一个结构体，叫做<code>SingleHost</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type SingleHost struct &#123;</div><div class="line">    handler     http.Handler</div><div class="line">    allowedHost string</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 它只包含两个field。</p>
<ul>
<li>如果是一个可用的Host，那么我们会调用嵌入的handler。</li>
<li>allowedHost 就是允许的Host。<br>&emsp;&emsp; 因为我们将其首字母小写，因此他们只对本包可见。我们需要给它定义已给构造函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func NewSingleHost(handler http.Handler, allowedHost string) *SingleHost &#123;</div><div class="line">    return &amp;SingleHost&#123;handler: handler, allowedHost: allowedHost&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><p>&emsp;&emsp; 现在需要实现真正的逻辑功能了。想要实现<code>http.Handler</code>，我们只需要实现他的一个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type Handler interface &#123;</div><div class="line">        ServeHTTP(ResponseWriter, *Request)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    host := r.Host</div><div class="line">    if host == s.allowedHost &#123;</div><div class="line">        s.handler.ServeHTTP(w, r)</div><div class="line">    &#125; else &#123;</div><div class="line">        w.WriteHeader(403)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ServeHTTP</code>只是检查请求的Host：</p>
<ul>
<li>如果Host和配置的allowed一直，那么调用handler的ServeHTTP。</li>
<li>如果不一直返回403<br>&emsp;&emsp;对于后一种情况，不仅不会得到应答，设置不知道有这个请求。<br>&emsp;&emsp;现在我们已经开发哈了中间件，只需要将其插入到需要的地方。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">singleHosted = NewSingleHost(myHandler, &quot;example.com&quot;)</div><div class="line">http.ListenAndServe(&quot;:8080&quot;, singleHosted)</div></pre></td></tr></table></figure>
<h3 id="另一种方式"><a href="#另一种方式" class="headerlink" title="另一种方式"></a>另一种方式</h3><p>&emsp;&emsp; 我们刚刚写的那个中间件很简单，它只有15行代码。写这样的中间件，可以使用样板方法。由于Go支持函数为一等公民和闭包，并且有<code>http.HandlerFunc</code>包装函数，我们可以通过他创建一个中间件，而不是将其放入到一个结构体中。下面是这个中间件的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func SingleHost(handler http.Handler, allowedHost string) http.Handler &#123;</div><div class="line">    ourFunc := func(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">        host := r.Host</div><div class="line">        if host == allowedHost &#123;</div><div class="line">            handler.ServeHTTP(w, r)</div><div class="line">        &#125; else &#123;</div><div class="line">            w.WriteHeader(403)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return http.HandlerFunc(ourFunc)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 我们定义了一个简单的函数<code>SingleHost</code>，它包装了<code>Handler</code>和允许的Host，在其内部我们实现了一个跟上面中间件类似的功能。我们内部的函数就是一个闭包，因此他可以访问外部函数的变量。最终HandlerFunc让我们可以将其变为Handler。<br>&emsp;&emsp; 觉得是使用HandlerFunc还是自己实现一个http.Handler完全取决于你自己。对于简单的情况，一个简单的函数就完全够了。如果你的中间件越来越多，那么就可以考虑实现自己的结构并把它们分开。<br>&emsp;&emsp; 同时标准库同时使用了两种功能。<code>StripPrefix</code>使用的是HandlerFunc，TimeoutHandler使用的是自定义的结构体。</p>
<h3 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h3><p>&emsp;&emsp; 我们的<code>SingleHost</code>并不重要，我们只检测一个属性，要么将他传递给其他的handler，要么直接返回。然而存在这种情况，我们的程序需要对处理完进行后续处理。</p>
<h3 id="添加数据是简单的"><a href="#添加数据是简单的" class="headerlink" title="添加数据是简单的"></a>添加数据是简单的</h3><p>&emsp;&emsp; 如果只是想简单的添加数据，那么使用Write就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">type AppendMiddleware struct &#123;</div><div class="line">    handler http.Handler</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    a.handler.ServeHTTP(w, r)</div><div class="line">    w.Write([]byte(&quot;Middleware says hello.&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 返回的结构肯定会包含<code>Middleware says hello.</code></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>&emsp;&emsp; 但是操作其他的数据有点困难。例如我们想要在它前面添加数据而不是后面追加。如果我们在原Handler之前调用Write，那么将会失去控制，因为第一个Write已经将他写入了。<br>&emsp;&emsp; 通过其他方法修改原始输出，例如替换字符串，改变响应header，或者设置状态码都不会起作用，因为当handler返回的时候数据已经返回到客户端了。<br>&emsp;&emsp; 为了实现这个功能，我们需要一个特殊的ResponseWriter，他可以想buffer一样工作，收集数据，存储以备使用和修改。然后我们将这个ResponseWriter传递给handler，而不是传递真是的RW，这样在其之前我们已经修改了它了。<br>&emsp;&emsp; 幸运的是在标准库中有这样的一个工具。在<code>net/http/httptest</code>包里的ResponseRecorder能做所有我们需要的：保存状态码，一个响应header的map，将body放入byte 缓冲中。虽然它是再测试中中使用的，但是很服务我们的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">type ModifierMiddleware struct &#123;</div><div class="line">    handler http.Handler</div><div class="line">&#125;</div><div class="line"></div><div class="line">func (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</div><div class="line">    rec := httptest.NewRecorder()</div><div class="line">    // passing a ResponseRecorder instead of the original RW</div><div class="line">    m.handler.ServeHTTP(rec, r)</div><div class="line">    // after this finishes, we have the response recorded</div><div class="line">    // and can modify it before copying it to the original RW</div><div class="line"></div><div class="line">    // we copy the original headers first</div><div class="line">    for k, v := range rec.Header() &#123;</div><div class="line">        w.Header()[k] = v</div><div class="line">    &#125;</div><div class="line">    // and set an additional one</div><div class="line">    w.Header().Set(&quot;X-We-Modified-This&quot;, &quot;Yup&quot;)</div><div class="line">    // only then the status code, as this call writes out the headers </div><div class="line">    w.WriteHeader(418)</div><div class="line"></div><div class="line">    // The body hasn&apos;t been written (to the real RW) yet,</div><div class="line">    // so we can prepend some data.</div><div class="line">    data := []byte(&quot;Middleware says hello again. &quot;)</div><div class="line"></div><div class="line">    // But the Content-Length might have been set already,</div><div class="line">    // we should modify it by adding the length</div><div class="line">    // of our own data.</div><div class="line">    // Ignoring the error is fine here:</div><div class="line">    // if Content-Length is empty or otherwise invalid,</div><div class="line">    // Atoi() will return zero,</div><div class="line">    // which is just what we&apos;d want in that case.</div><div class="line">    clen, _ := strconv.Atoi(r.Header.Get(&quot;Content-Length&quot;))</div><div class="line">    clen += len(data)</div><div class="line">    r.Header.Set(&quot;Content-Length&quot;, strconv.Itoa(clen))</div><div class="line"></div><div class="line">    // finally, write out our data</div><div class="line">    w.Write(data)</div><div class="line">    // then write out the original body</div><div class="line">    w.Write(rec.Body.Bytes())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后僵尸我们中间件的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 418 I&apos;m a teapot</div><div class="line">X-We-Modified-This: Yup</div><div class="line">Content-Type: text/plain; charset=utf-8</div><div class="line">Content-Length: 37</div><div class="line">Date: Tue, 03 Sep 2013 18:41:39 GMT</div><div class="line"></div><div class="line">Middleware says hello again. Success!</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样就开启了一种新的可能，包装的handler完全手控制。</p>
<h3 id="和其他handler分享数据"><a href="#和其他handler分享数据" class="headerlink" title="和其他handler分享数据"></a>和其他handler分享数据</h3><p>&emsp;&emsp; 在其他例子中，中间件可能需要暴露一些信息给其他中间件或者应用本身。例如nosurf需要给其他用户访问CSRF token的权限。<br>&emsp;&emsp; 最简单是是使用一个map，但是通常不希望这样。它将http.Request 的指针作为key，其他数据作为value。下面是nosurf的例子，Go的map非线程安全，所以要自己是实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type csrfContext struct &#123;</div><div class="line">    token string</div><div class="line">    reason error</div><div class="line">&#125;</div><div class="line"></div><div class="line">var (</div><div class="line">    contextMap = make(map[*http.Request]*csrfContext)</div><div class="line">    cmMutex    = new(sync.RWMutex)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>&emsp;&emsp; 数据由Token设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func Token(req *http.Request) string &#123;</div><div class="line">    cmMutex.RLock()</div><div class="line">    defer cmMutex.RUnlock()</div><div class="line"></div><div class="line">    ctx, ok := contextMap[req]</div><div class="line">    if !ok &#123;</div><div class="line">            return &quot;&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return ctx.token</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;源码可以再nosurf的项目的<a href="https://github.com/justinas/nosurf/blob/master/context.go" target="_blank" rel="external">context.go</a>中找到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://justinas.org/writing-http-middleware-in-go/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp; 再web开发的背景下，“中间件
    
    </summary>
    
    
      <category term="Go" scheme="https://mashuai.github.io/tags/Go/"/>
    
      <category term="HTTP" scheme="https://mashuai.github.io/tags/HTTP/"/>
    
      <category term="Middleware" scheme="https://mashuai.github.io/tags/Middleware/"/>
    
  </entry>
  
  <entry>
    <title>HTTP/2 和GO</title>
    <link href="https://mashuai.github.io/2015/11/12/HTTP-2-%E5%92%8CGO/"/>
    <id>https://mashuai.github.io/2015/11/12/HTTP-2-和GO/</id>
    <published>2015-11-12T03:39:21.000Z</published>
    <updated>2017-03-21T02:20:32.560Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.ianlewis.org/en/http2-and-go" target="_blank" rel="external">原文地址</a><br>&emsp;&emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功能包括连接复用，首部压缩。再Go的标准库中暂时还没有HTTP/2的实现，但是现在有很多正在开发的库可以用来在Go中实现HTTP/2的server和client。<br>&emsp;&emsp; Brad Fitzpatrick实现了一个<a href="https://godoc.org/golang.org/x/net/http2" target="_blank" rel="external">golang.org/x/net/http2</a>的库，这个库甚至最终会加入到标准库中，不过他现在正在开发，所以在其他的库中。因为他现在的开发很活跃，所有情况因人而异，但是如果你想实现HTTP/2的服务器，仍然可以使用这个库。</p>
<h3 id="创建HTTP-2服务器"><a href="#创建HTTP-2服务器" class="headerlink" title="创建HTTP/2服务器"></a>创建HTTP/2服务器</h3><p>&emsp;&emsp; 使用http2的库写一个服务器是很简单的。http2库和标准库的http包集成在一起，需要调用<code>http2.ConfigureServer()</code>来配置一个普通http使用HTTP/2协议。如果需要通过浏览器访问或者降级到HTTP 1.x 协议，那么你需要设置TLS 加密。虽然加密不是必须的，但是现在还没有浏览器支持非加密的HTTP/2协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;log&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line">    &quot;os&quot;</div><div class="line"></div><div class="line">    &quot;golang.org/x/net/http2&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    cwd, err := os.Getwd()</div><div class="line">    if err != nil &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    srv := &amp;http.Server&#123;</div><div class="line">        Addr:    &quot;:8000&quot;, // Normally &quot;:443&quot;</div><div class="line">        Handler: http.FileServer(http.Dir(cwd)),</div><div class="line">    &#125;</div><div class="line">    http2.ConfigureServer(srv, &amp;http2.Server&#123;&#125;)</div><div class="line">    log.Fatal(srv.ListenAndServeTLS(&quot;server.crt&quot;, &quot;server.key&quot;))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建HTTP-2-客户端"><a href="#创建HTTP-2-客户端" class="headerlink" title="创建HTTP/2 客户端"></a>创建HTTP/2 客户端</h3><p>&emsp;&emsp; 现在使用http2的库创建客户端很hacky。虽然它会输出很多调试日志，但是对于大多数情况下运行的很好。可以使用<code>http2.Transport</code>对象，将他传给<code>http</code>包的client。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line"></div><div class="line">import (</div><div class="line">    &quot;fmt&quot;</div><div class="line">    &quot;io/ioutil&quot;</div><div class="line">    &quot;log&quot;</div><div class="line">    &quot;net/http&quot;</div><div class="line"></div><div class="line">    &quot;golang.org/x/net/http2&quot;</div><div class="line">)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    client := http.Client&#123;</div><div class="line">        // InsecureTLSDial is temporary and will likely be</div><div class="line">        // replaced by a different API later.</div><div class="line">        Transport: &amp;http2.Transport&#123;InsecureTLSDial: true&#125;,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    resp, err := client.Get(&quot;https://localhost:8000/&quot;)</div><div class="line">    if err != nil &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    body, err := ioutil.ReadAll(resp.Body)</div><div class="line">    if err != nil &#123;</div><div class="line">        log.Fatal(err)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fmt.Println(string(body))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h3><p>&emsp;&emsp; 如果你对HTTP/2协议感兴趣，那么可以参考<a href="https://http2.github.io/" target="_blank" rel="external">HTTP/2 主页</a>，这个页面有很多其他资料的连接还有其他语言的实现。<br>&emsp;&emsp; 如果你想知道HTTP/2的服务端和客户端是如何实现的，那么<a href="https://github.com/Jxck/http2" target="_blank" rel="external">Jxck’s http2 implementation</a>的实现就很值得一读。Jxck通过对标准的HTTP库的TLSNextProto设置一个钩子来实现的。你可以再这里阅读一些<a href="https://github.com/Jxck/http2/blob/master/sample/http.go" target="_blank" rel="external">示例</a>。<br>&emsp;&emsp; grpc-go 库同样也有自己的服务端和客户端的实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.ianlewis.org/en/http2-and-go&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt;&lt;br&gt;&amp;emsp;&amp;emsp; HTTP/2是一个添加了一些新功能的HTTP的新版本，这些功
    
    </summary>
    
    
      <category term="Translate" scheme="https://mashuai.github.io/tags/Translate/"/>
    
      <category term="HTTP/2" scheme="https://mashuai.github.io/tags/HTTP-2/"/>
    
      <category term="Go" scheme="https://mashuai.github.io/tags/Go/"/>
    
  </entry>
  
</feed>
